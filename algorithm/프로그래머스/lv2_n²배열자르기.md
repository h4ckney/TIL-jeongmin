# 🧾 오답노트 — n² 배열 자르기 (프로그래머스 Lv.2)

### 📅 풀이 일자

2025-11-11

---

## 📌 문제 요약

크기 `n×n`의 특수한 2차원 배열이 정의되어 있고, 이 배열을 1차원으로 펼쳤을 때의 구간 `[left, right]`만 잘라 반환한다. 전체 배열을 실제로 생성하지 않고 해결해야 효율성 통과.

---

## 💀 나의 초기 접근 & 실패 원인

```text
- 전체 n×n 배열을 직접 생성 → 2차원 → flat() → slice(left, right+1)
```

### ❌ 문제점

| 항목        | 내용                             | 영향                             |
| ----------- | -------------------------------- | -------------------------------- |
| 공간 복잡도 | n×n 전체를 메모리에 생성         | 대규모 n에서 메모리 초과 (O(n²)) |
| 시간 복잡도 | 불필요한 채우기/평탄화 연산      | 시간 낭비 (O(n²) + flat)         |
| 목표 불일치 | 필요한 건 `[left, right]` 구간뿐 | 계산 대상 대비 과도한 연산       |

---

## ✅ 올바른 사고 전환

> **핵심**: 전체를 만들지 말고, `i ∈ [left, right]` 각각에 대해 그 위치의 값을 **직접 계산**한다.

### 1) 1차원 ↔ 2차원 인덱스 매핑

- `row = ⌊i / n⌋`
- `col = i % n`

### 2) 값의 규칙(배열 정의)

- **각 칸의 값**: `max(row, col) + 1`
  (1-베이스 규칙을 반영한 형태)

➡️ 이 두 줄로 특정 `i`의 값을 O(1)로 계산 가능.

---

## 🧠 풀이 구조(코드 없이 로직만)

1. 결과 배열 `res` 길이를 `right-left+1`로 준비
2. `i = left..right` 순회

   - `row = ⌊i / n⌋`, `col = i % n`
   - `res[i-left] = max(row, col) + 1`

3. `res` 반환

**복잡도**: 시간 O(right-left+1), 추가 공간 O(1) (출력 제외)

---

## 🧪 수작업 검증 체크리스트

- 경계값

  - `left = 0`, `right = 0` (첫 칸)
  - `left = n-1`, `right = n-1` (1행 마지막 칸)
  - `left = n`, `right = n` (2행 첫 칸)
  - `left = right` (단일 원소)
  - `right`가 정확히 `(k+1)*n - 1` (행의 끝)일 때

- 임의의 작은 n (예: n=4)로 2차원 표를 손으로 적어 패턴 확인

---

## 🧩 디버깅 포인트

- `row`/`col` 계산에서 정수 나눗셈(⌊ ⌋)과 나머지 혼동 여부
- 0-베이스 vs 1-베이스 값 보정(`+1`) 누락 여부
- `res` 인덱싱: `res[i-left]`로 채우는지 확인

---

## ⚖️ 대안 비교

| 접근                  | 장점              | 단점              | 비고                  |
| --------------------- | ----------------- | ----------------- | --------------------- |
| 전체 생성 후 슬라이스 | 직관적, 구현 쉬움 | 메모리/시간 O(n²) | 대입문제 실패 원인    |
| **직접 계산(권장)**   | 메모리 절약, 빠름 | 인덱스 실수 여지  | 인덱스 매핑 숙련 필요 |

---

## 🧠 기억 메모(재발 방지)

- “**필요한 인덱스만 직접 계산**” 가능한지 먼저 의심하자.
- 1D↔2D 매핑 기본형: `row=⌊i/n⌋`, `col=i%n`는 외워두기.
- 값이 **행/열의 단조 패턴**을 따라가면 `max/min(row,col)` 형태를 먼저 떠올려보기.

---

## 🔁 복습 과제

- [ ] 1D↔2D 인덱스 변환 3종(행우선/열우선/지그재그) 연습
- [ ] 경계 테스트 세트로 자동 검증 함수 만들기
- [ ] 유사 문제: 1차원 슬라이싱으로 2차원 특정 영역만 빌드하기(부분 행렬만)
