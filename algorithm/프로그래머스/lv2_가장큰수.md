# 🧠 오답노트: 프로그래머스 Lv.2 — 가장 큰 수 (2025.11.01)

## 📅 풀이 시간

**약 55분 (본질 이해까지 1시간)**

---

## 📌 문제 요약

주어진 숫자들을 이어붙여 만들 수 있는 **가장 큰 수를 문자열 형태로 반환**한다.

---

## ❌ 잘못된 접근 (처음 시도)

- **끝자리 비교**로 정렬(`String(b).split('')[bLeng-1]`)
- 자릿수 단위 비교는 **전이성(Transitivity)** 깨짐
- 일부 케이스 `[3,30,34]`, `[12,121]` 등에서 오류 발생

💬 **원인**

→ “부분 자릿수 비교”는 **전역 최적**을 보장하지 않는다.
→ 정렬은 **모든 쌍의 조합 결과(ab vs ba)**를 기준으로 해야 함.

---

## ✅ 정답 접근

```js
function solution(numbers) {
  const answer = numbers
    .sort((a, b) => (b + "" + a).localeCompare(a + "" + b))
    .join("");
  return answer[0] === "0" ? "0" : answer;
}
```

- (b+a) vs (a+b) → 두 수를 **양방향으로 붙여서** 사전식 비교
- `join('')`으로 이어붙임
- 전부 0인 경우 "0" 처리
- `Number()` 사용 금지 (정밀도 깨짐)

---

## 🧩 핵심 개념 정리

| **개념**                         | **설명**                                                  |
| -------------------------------- | --------------------------------------------------------- |
| **전이성(Transitivity)**         | 정렬 비교가 항상 일관돼야 함. (a>b, b>c이면 a>c여야 함)   |
| **교환 논증(Exchange Argument)** | 인접한 두 수가 규칙에 어긋나면 바꾸는 게 전체 결과를 키움 |
| **국소 비교 ≠ 전역 최적**        | 자릿수 비교는 일부만 본 것, 결합 비교는 전체를 본 것      |
| **정밀도 주의**                  | JS의 `Number()`는 15자리 이후 깨짐 → 문자열 유지해야 함   |

---

## 🧪 카나리 테스트 케이스 (전이성 검증용)

| **입력**    | **올바른 결과** |
| ----------- | --------------- |
| [3, 30, 34] | "34330"         |
| [12, 121]   | "12121"         |
| [83, 830]   | "83830"         |
| [0, 0, 0]   | "0"             |

---

## ⏱️ 시간 기준 목표

| **구분**              | **목표 시간** |
| --------------------- | ------------- |
| 1회차(이해 단계)      | 30~45분       |
| 3회차 이후(실전 감각) | 15~20분       |
| 5회차 이후(암기 수준) | 10분 이내     |

---

## 💡 교훈 요약

> “자릿수는 현상이고, 결합은 본질이다.”
> “두 수의 결합 결과(ab vs ba)가 크기를 결정한다.”
> “이 비교는 전이성과 교환 논증을 모두 만족시킨다.”

---

## 🔁 재학습 포인트

- JS `sort()` 비교 함수의 반환 규칙 숙지 (음수/0/양수 의미)
- `localeCompare()`로 문자열 사전식 비교 익숙해지기
- [ab, ba] 패턴 문제 한두 개 더 풀어보기 (“가장 작은 수”, “문자열 정렬” 등)

---
