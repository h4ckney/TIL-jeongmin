# 💡 2개 이하로 다른 비트 (Programmers / Lv2)

### ❌ 나의 시도

```js
function solution(numbers) {
  var answer = [];

  const minBit = (num, idx) => {
    let twoForNum = numbers[idx].toString(2).split('')
    const iForNum = (num + 1).toString(2).split('')
    let defferCnt = 0

    if (twoForNum.length < iForNum.length) {
      const remainZero = iForNum.length - twoForNum.length
      twoForNum = new Array(remainZero).fill('0').concat(twoForNum)
    }

    for (let k = 0; k < twoForNum.length; k++) {
      if (twoForNum[k] !== iForNum[k]) defferCnt += 1
    }

    if (defferCnt > 2) return minBit(num + 1, idx)
    else return num + 1
  }

  answer = numbers.map((v, i) => minBit(v, i))
  return answer
}


⸻

⚙️ 문제 의도

“주어진 수보다 크면서 비트가 2개 이하만 다른 수 중 가장 작은 수를 구하라.”

⸻

💣 내가 놓친 부분

구분	문제점	설명
①	재귀 호출 무한 증가 → Stack Overflow	큰 수일 경우 minBit(num + 1, idx)가 수십만 번 호출되며 스택 초과 발생
②	비효율적 비교 방식	toString(2) → 문자열 변환은 느리고 불필요
③	문제의 수학적 규칙 간과	짝수는 +1, 홀수는 특정 비트 패턴만 바꾸면 해결 가능
④	시간 복잡도 폭발	최악의 경우 O(N×K) (K는 반복 횟수), 정답은 O(N) 또는 O(1) 가능


⸻

✅ 정답 접근

🔹 핵심 규칙
	•	짝수(n의 마지막 비트가 0) → 답 = n + 1
	•	홀수(n의 마지막 비트가 1) → 오른쪽부터 01을 10으로 바꾸는 것이 최소 변화
	•	공식: n + 1 + ((n ^ (n + 1)) >> 2)

⸻

🧩 정답 코드

function solution(numbers) {
  const ans = numbers.map((x) => {
    let n = BigInt(x);
    if ((n & 1n) === 0n) return Number(n + 1n);          // 짝수
    const t = n ^ (n + 1n);                               // 홀수
    return Number(n + 1n + (t >> 2n));
  });
  return ans;
}


⸻

🧠 배운 점
	1.	재귀는 “필요한 이유”가 없으면 피해야 한다.
→ 반복문이나 수학공식으로 바꿀 수 있으면 무조건 바꾸기.
	2.	비트 연산(^, &, >>, <<)은 문자열 비교보다 훨씬 빠르다.
	3.	**문제의 규칙을 찾으면 시간 복잡도를 O(1)**로 줄일 수 있다.
→ “시뮬레이션보다 패턴 분석이 우선.”
	4.	BigInt를 사용해야 안전하다.
→ JS의 정수 연산 한계(2⁵³−1)를 넘는 입력이 존재하기 때문.

⸻

📌 다음에 비슷한 유형이 나오면?
	•	비트 차이 / 짝홀수 / 최소 변경 문제 → XOR, AND, SHIFT 먼저 떠올리기
	•	재귀 대신 while / 수학공식 단순화 시도
	•	시간 복잡도 예측 → 스택 위험 미리 판단

⸻

📚 TIL-jeongmin / Algorithm / Programmers / Lv2

---
```
