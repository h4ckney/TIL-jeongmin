# 🧾 오답노트 — 귤 고르기 (2025.10.24)

> “귤 k개를 선택할 때 종류 수를 최소화하라.”
> (그리디 / 빈도 기반 정렬)

---

## ❌ 나의 시도

```js
const leng = Math.max(...tangerine)
const newArr = new Array(leng + 1)...
```

### 🧩 문제점

- 귤 크기의 최댓값(1천만)을 기준으로 배열 생성 → **불필요한 메모리 낭비**.
- 값의 ‘범위’가 아니라 ‘빈도’만 중요했음.

### 💡 교훈

> 문제에서 **값의 범위가 너무 크면**, 배열 대신 **Map/객체**로 빈도만 세야 한다.

---

## ⚠️ 또 다른 실수

```js
if (picked >= k) return;
```

### 🧩 문제점

- 조건을 만족했을 때 `return;`만 해서 **undefined 리턴**.
- 실제로는 `types` 값을 반환해야 했음.

### 💡 교훈

> 코테에서는 **return 값이 명확한지 항상 확인**하자. (특히 함수형 문제)

---

## ✅ 정답 접근

### 핵심 로직

1. 귤 크기별 개수 세기 → Map/객체 이용.
2. 개수 배열로 변환 후 내림차순 정렬.
3. 큰 수부터 누적하며 `picked >= k` 될 때까지 반복.
4. 최소 종류 수(`types`) 반환.

### 예시

```
입력: [1,3,2,5,4,5,2,3]
Map: {1:1, 2:2, 3:2, 4:1, 5:2}
정렬된 빈도: [2,2,2,1,1]
```

---

## 🧩 정답 코드

```js
function solution(k, tangerine) {
  const orangeMap = new Map();

  // 빈도 세기
  for (let t of tangerine) {
    orangeMap.set(t, (orangeMap.get(t) || 0) + 1);
  }

  // 빈도 배열 & 정렬
  const counts = Array.from(orangeMap.values()).sort((a, b) => b - a);

  let picked = 0,
    types = 0;
  for (let c of counts) {
    picked += c;
    types += 1;
    if (picked >= k) return types; // ✅ 최소 종류 수 반환
  }
}
```

---

## 🧠 배운 점

1. **Map으로 빈도 세기** → 큰 범위 배열보다 효율적.
2. **그리디 핵심:** 큰 빈도부터 담으면 최소 종류 확보.
3. **리턴 값 검증 습관화** → undefined 방지.
4. **종류 수 증가 시점:** 귤 종류 하나 사용할 때마다 `types++`.

---

## 📌 다음에 비슷한 유형이 나오면

**키워드:** “빈도 기반 선택”, “그리디”, “Map 활용”, “정렬 후 누적합”

### ✅ 절차 체크리스트

- [ ] 배열 범위가 클 때 Map/객체 사용 판단.
- [ ] 빈도 기반 정렬이 가능한지 검토.
- [ ] 누적 조건(k 이상 등) 확인 후 리턴값 검증.
- [ ] 메모리 효율성 고려 (큰 배열 생성 지양).

---

## 🔁 복습 체크

- [ ] 다시 풀기 (1회차)
- [ ] 다시 풀기 (2회차)
- [ ] 설명 없이 구현 가능 ✅
