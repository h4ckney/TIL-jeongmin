# 🧾 오답노트 — 소수 만들기 (2025.10.26)

> “주어진 배열에서 서로 다른 3개의 수를 더했을 때, 소수가 되는 조합의 개수를 구하라.”
> (조합 / 수학 / 완전 탐색)

---

## ❌ 나의 시도

```js
for (let i = 0; i < nums.length; i++) {
  for (let j = 0; j < nums.length; j++) {
    for (let k = 0; k < nums.length; k++) {
      const sum = nums[i] + nums[j] + nums[k];
      if (isPrime(sum)) count++;
    }
  }
}
```

### 🧩 문제점

- 같은 숫자를 여러 번 선택하거나 `(1,2,3)`과 `(3,2,1)` 같은 **중복 조합** 발생.
- 결과적으로 **중복 카운트** 및 **불필요한 연산 증가**.
- 조합 문제의 기본 규칙(`i < j < k`)을 적용하지 않음.

### 💡 교훈

> **조합 문제**에서는 반드시 인덱스 조건(`i < j < k`)을 사용해 **중복을 제거**해야 한다.

---

## ✅ 정답 접근

### 🧠 핵심 로직

1. **세 수 조합 만들기 (i < j < k)** → 중복 제거 및 순서 고려 X.
2. **세 수의 합 계산**
3. **소수 판별 (isPrime 함수 이용)**
4. **소수이면 count++**

---

## 🧩 정답 코드

```js
function solution(nums) {
  let count = 0;

  // 소수 판별 함수
  const isPrime = (num) => {
    if (num < 2) return false;
    for (let i = 2; i <= Math.sqrt(num); i++) {
      if (num % i === 0) return false;
    }
    return true;
  };

  // 3개 조합 뽑기
  for (let i = 0; i < nums.length - 2; i++) {
    for (let j = i + 1; j < nums.length - 1; j++) {
      for (let k = j + 1; k < nums.length; k++) {
        const sum = nums[i] + nums[j] + nums[k];
        if (isPrime(sum)) count++;
      }
    }
  }

  return count;
}
```

---

## ⚙️ 복잡도 분석

| 구분      | 복잡도      | 설명                          |
| --------- | ----------- | ----------------------------- |
| 조합 생성 | O(n³)       | 세 겹 반복문                  |
| 소수 판별 | O(√n)       | 합에 대한 검사                |
| 전체      | **O(n³√n)** | n이 작으므로 충분히 통과 가능 |

---

## 🧠 배운 점

1. 조합 문제는 항상 **i < j < k 패턴**으로 접근한다.
2. “조합 → 합 → 소수 판별 → 카운트” 순서로 구조화하면 실수 줄어듦.
3. 소수 판별 시 √n까지만 확인하면 효율적.
4. 완전탐색도 입력이 작을 땐 충분히 통과할 수 있다.

---

## 📌 다음에 비슷한 유형이 나오면

**키워드:** “조합”, “소수 판별”, “완전탐색”, “중복 제거”

### ✅ 절차 체크리스트

- [ ] 중복 제거 조건(`i<j<k`) 적용
- [ ] 조합 → 합 → 조건판별 순서 유지
- [ ] √n 최적화 적용
- [ ] count 증가 시점 명확히 구분

---

## 🔁 복습 체크

- [ ] 다시 풀기 (1회차)
- [ ] 다시 풀기 (2회차)
- [ ] 설명 없이 구현 가능 ✅
