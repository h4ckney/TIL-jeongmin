# HTTP 완벽 가이드 (HTTP: The Definitive Guide)

- HTTP를 이해하는 것이 중요한가?
  - 월드와이드 웹을 지탱하는 가장 중요한 기술 두 가지는 HTML과 HTTP이다. 이 두 기술은 팀버너스-리가 웹을 발명할 때 함께 만들어졌다.
  - 이 둘 중 하나라도 빠지면 웹은 성립하지 않으며, 한편으로 이 둘만 있어도 어떻게든 웹은 성립할 수 있다.
- HTTP를 이해한다는 것은 웹이 어떻게 동작하는지 이해한다는 것이며, 이를 깊이 이해하면 웹 프로그래밍을 하면서, 웹 서버를 조작하면서, 그리고 네트워크를 관리하면서 정확한 근거에 기반한 올바른 기술적 판단을 내려야 할 때 큰 도움이 된다.

## 1. HTTP

- 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에 전송 중 손상되거나 꼬이지 않음을 보장한다.

### 1.2 웹클라이언트 서버

- 클라이언트 요청 → 서버 확인 → 서버 응답 → 클라이언트 화면 노출

### 1.3 리소스

- 웹 서버는 웹 리소스를 관리하고 제공한다 → 정적파일, 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수 있다. (동적 콘텐츠)

#### 1.3.1 미디어 타입

- 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙인다.

  - MIME (Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장) → 긴 문장으로는 처음 알았다…
  - 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었다.
  - 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다.

- 예시
  - HTML 작성된 문서: `text/html`
  - plain ASCII 텍스트: `text/plain`
  - JPEG 이미지: `image/jpeg`
  - GIF 이미지: `image/gif`
  - 애플 퀵타임 동영상: `video/quicktime`

#### 1.3.3 URI

- 서버 리소스 이름은 통합 자원 식별자
  - (uniform resource identifier) 혹은 URI
  - URI는 인터넷의 운편물 주소 같은 것으로, 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.
  - URI에는 두 가지가 있다. URL, URN

#### 1.3.3 URL

- 통합 자원 지시자(uniform resource locator, URL)는 리소스 식별자의 가장 흔한 형태다.
- URL은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.

| **URL**                                                      | **설명**                                                                     |
| ------------------------------------------------------------ | ---------------------------------------------------------------------------- |
| http://www.oreilly.com/index.html                            | 오라일리 출판사 홈페이지의 URL                                               |
| http://www.yahoo.com/images/logo.gif                         | 야후 웹 사이트 로고의 URL                                                    |
| http://www.joes-hardware.com/inventory-check.cgi/item=12731  | 물품 #12731의 재고가 있는지 확인하는 프로그램에 대한 URL                     |
| ftp://joetools:4u8f@ftp.joes-hardware.com/locking-pliers.gif | 비밀번호로 보호되는 FTP를 통해 locking-pliers.gif 이미지 파일에 접근하는 URL |

#### 1.3.4 URN

- URI의 두 번째 종류는 유니폼 리소스 이름(uniform resource name, URN)이다.
- URN은 콘텐츠를 이루는 한 리소스에 대해 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 한다.

### 1.4 트랜잭션

- 클라이언트가 웹 서버와 리소스를 주고 받기 위해 HTTP를 어떻게 사용하는지 자세하게 알아보면 아래와 같다.
  - HTTP 메시지라고 불리는 정형화된 데이터 덩어리를 이용해 이뤄진다.

#### 1.4.1 메서드

- HTTP는 HTTP 메서드라고 불리는 여러 가지 종류 요청 명령을 지원한다.
- 모든 HTTP 요청 메시지는 한 개의 메서드를 갖는다.
- 흔히 쓰이는 HTTP 메서드 다섯 개를 열거하고 있다.
  - GET, PUT, DELETE, POST, HEAD
    - **개인적으로 느꼈을 때 REST API에서 사용하는 대표적인 4가지 메서드는 GET, POST, PUT, DELETE이다. (상황에 따라 PATCH도 추가로 사용된다.)**

#### 1.4.2 상태코드

- 모든 HTTP 응답 메시지는 상태 코드와 함께 반환된다.
- 상태 코드는 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세 자리 숫자다.
  - 200(정상), 302(리디렉션, 임시이동), 404(없음)

### 1.6 TCP커넥션

#### 1.6.1 TCP/IP

- HTTP는 애플리케이션 계층 프로토콜이다. HTTP 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않는다.
- 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에 맡긴다.
  - “오류 없는 데이터 전송” → TCP의 **체크섬 + ACK/재전송**
  - “순서에 맞는 전달” → TCP의 **시퀀스 번호**
  - “조각나지 않는 데이터 스트림” → TCP가 스트림 단위로 연결을 유지 (IP 단편화와 무관하게 상위 레벨에서 연속된 바이트 스트림 제공)

| 계층              | 프로토콜 / 구성요소      | 설명                                                |
| ----------------- | ------------------------ | --------------------------------------------------- |
| 애플리케이션 계층 | HTTP                     | 웹 애플리케이션 통신 담당                           |
| 전송 계층         | TCP                      | 신뢰성 있는 데이터 전송 보장 (순서, 무결성, 재전송) |
| 네트워크 계층     | IP                       | 패킷을 목적지까지 전달 (주소 지정, 라우팅)          |
| 데이터 링크 계층  | 네트워크 인터페이스      | 네트워크 하드웨어와 상호작용, 프레임 단위 전송      |
| 물리 계층         | 물리적 네트워크 하드웨어 | 전기적/광학적 신호를 실제로 송수신                  |

#### 1.6.2 접속, IP 주소 그리고 포트번호

- HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜 (IP) 주소와 포트 번호를 사용해 클라이언트 사이에 TCP/IP 커넥션을 맺어야 한다.
- HTTP 80과 HTTPS 443만 일단 알고 있어도 충분 여기서는..
  - 21 FTP, 22 SSH, 23 TELNET 는 알고 있으면 좋다.
  - 53는 Router 53으로 AWS에서 쓰고 있는 것으로 기억하면 좋다.

## 웹 브라우저가 문서를 가져오는 과정

| 단계 | 설명                                                               |
| ---- | ------------------------------------------------------------------ |
| (a)  | 웹 브라우저는 서버의 URL에서 **호스트명**을 추출한다.              |
| (b)  | 웹 브라우저는 추출한 **호스트명을 IP 주소로 변환(DNS 조회)** 한다. |
| (c)  | 웹 브라우저는 URL에서 **포트 번호**(있다면)를 추출한다.            |
| (d)  | 웹 브라우저는 웹 서버와 **TCP 커넥션**을 맺는다.                   |
| (e)  | 웹 브라우저는 서버에 **HTTP 요청**을 보낸다.                       |
| (f)  | 서버는 브라우저에 **HTTP 응답**을 돌려준다.                        |
| (g)  | 커넥션이 닫히면, 브라우저는 **문서를 화면에 렌더링**한다.          |

### 1.7 프로토콜 버전

- 책에서는 프로토콜 버전으로 0.9부터 2.0까지만 나와있지만 현재는 3.0까지 존재한다. (책이 14년에 나왔으므로..)
- [inpa 블로그 - HTTP/3 통신 기술](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-30-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
- [Wikipedia - HTTP/3](https://en.wikipedia.org/wiki/HTTP/3)

## 1.8 웹의 구성요소

### 1.8.1 프락시

- 웹 보안, 애플리케이션 통합, 성능 최적화를 위해 사용되는 **옵션 구성요소** (예: Nginx, HAProxy, CloudFront)
- 클라이언트와 서버 사이에 위치해 모든 HTTP 요청을 받아 서버로 전달한다.
- 주로 **보안 목적**으로 쓰이며, 신뢰할 수 있는 중개자 역할을 한다.
- 요청과 응답을 **필터링**할 수 있다. (예: SSL 종료, 접근 제어, 광고/악성 요청 차단)
- **효과**: 보안 강화, 트래픽 관리(로드밸런싱, 캐싱, 압축), 서비스 안정성 확보

---

### 1.8.2 캐시

- 캐시 프락시는 프락시의 한 형태로, 자주 요청되는 문서의 **사본을 저장**한다.
- 동일한 요청이 들어오면 서버 대신 캐시에서 응답한다.
- **효과**: 네트워크 비용 절감, 응답 속도 향상, 서버 부하 감소

---

### 1.8.3 게이트웨이

- 다른 서버들의 중개자로 동작하는 특별한 서버
- 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용한다.
- 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다.
  - 예: HTTP/FTP 게이트웨이 → FTP URI에 대한 HTTP 요청을 받아들여, FTP 프로토콜을 통해 문서를 가져온다.

---

### 1.8.4 터널

- 두 커넥션 사이에서 데이터를 열어보지 않고 그대로 전달하는 HTTP 애플리케이션
- 대표적인 예: 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송하여, **웹 트래픽만 허용하는 방화벽**을 통과시키는 방식
- HTTP/SSL 터널은 HTTP 요청을 받아 목적지 주소와 포트번호로 커넥션을 맺는다.

---

### 1.8.5 에이전트

- 사용자를 대신해 HTTP 요청을 만드는 클라이언트 프로그램
- 모든 웹 요청 애플리케이션은 HTTP 에이전트
  - 예: 구글봇, AI 관련 크롤러 (사람 개입 없이 콘텐츠를 가져옴)

---

## 1.9 시작의 끝

- 이 장에서는 HTTP가 **멀티미디어 전송 프로토콜**로서 수행하는 역할을 다뤘다.

⸻

📖 2025년 9월 25일 — 2장 URL과 리소스 정리

⸻

2. URL과 리소스

책에서는 길거리 주소, 버스 노선 번호, 은행 계좌 같은 예시를 들며, **이름 체계(표준)**가 존재하기 때문에 리소스를 쉽게 공유할 수 있다고 설명한다.
• URL은 인터넷의 리소스를 가리키는 표준 이름이다.
• URL의 문법: 여러 컴포넌트가 어떤 의미를 가지며 무엇을 수행하는지 이해해야 한다.
• 상대 URI와 확장 URL: 여러 웹 클라이언트가 지원.
• URL의 인코딩과 문자 규칙
• 공통 URL 스킴: 여러 인터넷 정보 시스템에 적용.
• URN: 기존 이름을 유지하면서도 객체를 다른 장소로 옮길 수 있게 해주는 확장 개념.

⸻

2.1 인터넷의 리소스 탐색하기
• URL은 브라우저가 정보를 찾는 데 필요한 리소스의 위치를 가리킨다.
• URL을 통해 사람과 애플리케이션은 인터넷상의 수십억 개 리소스를 찾고, 사용하며, 공유할 수 있다.
• URL은 HTTP뿐 아니라 다른 프로토콜을 통해서도 접근 가능하다.
• 사용자는 브라우저에 URL을 입력하고, 브라우저는 뒤에서 적절한 프로토콜을 사용해 요청을 전송한다.

예시
• http://www.host/sasonal/index.html → 스킴 + 도메인 + 경로
• mailto:president@test.com → 메일 전송 프로토콜
• ftp://ftp.도메인/pub/test.xls → FTP 서버 파일
• rtsp://도메인:포트/cto_video → 스트리밍 영상

⸻

2.1.1 URL 이전의 암흑의 시대

웹과 URI가 등장하기 전에는 애플리케이션마다 다른 방식으로 리소스를 분류하고 접근해야 했다.
• 현재: URL/URI를 통해 통합된 방식으로 접근
• 과거: 서비스별 독자적 접근 방식
• FTP: 호스트명 + 포트 + 디렉토리 구조 필요
• Usenet 뉴스 그룹: 그룹명 + 기사 ID
• Telnet: 특정 포트 접속 후 커맨드 입력
• 로컬 DB: 쿼리나 고유 키 필요

⸻

2.2 URL 컴포넌트

| **컴포넌트**      | **설명**                                              | **기본값**       |
| ----------------- | ----------------------------------------------------- | ---------------- |
| **스킴**          | 리소스를 가져오기 위한 프로토콜                       | 없음             |
| **사용자 이름**   | 리소스 접근 시 필요한 사용자 이름                     | anonymous        |
| **비밀번호**      | 사용자 이름과 함께 쓰이는 인증 수단 (거의 사용 안 함) | 없음             |
| **호스트**        | 리소스를 가진 장비의 이름이나 IP 주소                 | 없음             |
| **포트**          | 서버가 열어둔 네트워크 포트                           | 스킴에 따라 다름 |
| **경로**          | 서버 내 리소스 위치                                   | 없음             |
| **파라미터**      | 리소스에 전달하는 이름/값 쌍의 매개 변수              | 없음             |
| **질의어(Query)** | 데이터베이스 질의 등 요청 시 전달되는 문자열          | 없음             |
| **프래그먼트**    | 리소스 내부 특정 위치 지정 (#anchor)                  | 없음             |

예시
• 사용자 이름/비밀번호: ftp://username:password@ftp.example.com/file.txt
• 파라미터: http://example.com/content;lang=ko;version=2
• 질의어: https://www.google.com/search?q=nextjs+seo&hl=ko

⸻

2.2.1 URL 파라미터 (;param=value)
• 의미: 리소스 경로에 추가 속성을 전달하는 방식
• 등장 배경: 쿼리스트링(?)이나 쿠키가 보편화되기 전, HTTP 초창기에 사용됨
• 사례
• 리소스 옵션 지정: http://example.com/index.html;lang=ko;version=2
• 세션 식별자 전달: http://example.com/app/main;jsessionid=1234567890ABCDEF
• 현재
• 거의 사용되지 않음
• RESTful API, Query String, Header로 대체
• 레거시 Java 웹 서버(JSP/Servlet)에서 ;jsessionid 형태로 가끔 등장

⸻

2.3 단축 URL
• 상대 URL을 사용하면 리소스를 간결하게 기술 가능.
• 일부 브라우저/클라이언트는 사용자가 입력한 URL 일부를 기반으로 나머지를 자동 완성하기도 함.

⸻

2.3.1 상대 URL

1. 상대 URL (Relative URL)
   • 문서 내에서 ./hammers.html처럼 간단히 표현
   • 장점: 문서를 다른 서버/디렉토리로 옮겨도 상대 경로는 그대로 유지

예시:

<a href="./hammers.html">Hammers</a>

    •	기준(Base URL): http://www.joes-hardware.com/tools.html
    •	상대 URL: ./hammers.html
    •	절대 URL: http://www.joes-hardware.com/hammers.html

⸻

2. 기저 URL (Base URL)

상대 URL을 해석할 때 기준이 되는 URL.
• HTML 문서 자체 URL
• <base> 태그로 명시
• 리소스에서 암시적으로 제공되는 경우

⸻

3. 기저 URL이 없는 경우
   • 문서가 로컬 파일로만 제공되는 경우
   • 상대 URL 해석 불가 → 불완전 상태

⸻

4. 상대 경로 해석 규칙
   • ./, ../ 문법을 적용해 절대 경로로 변환

   • 예시:
   • 기저 URL: http://example.com/dir/tools.html
   • 상대 URL: ../images/icon.png
   • 절대 URL: http://example.com/images/icon.png

⸻

📖 2025년 9월 26일 — 2.4 안전하지 않은 문자 & 2.5 스킴 정리

⸻

## 2.4 안전하지 않은 문자

- URL은 잘 호환되도록 설계되었다.
- URL은 인터넷에 있는 모든 리소스가 여러 프로토콜을 통해서 전달될 수 있도록, 각 리소스에 유일한 이름을 지을 수 있게 설계되었다.
- SMTP(메일 프로토콜)는 특정 문자를 제거할 수도 있는 전송 방식을 사용한다.
- 문자가 제거되는 일을 피하고자 URL은 상대적으로 작고 일반적으로 안전한 알파벳 문자만 포함하도록 허락한다.
- 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게 하였다.

### 2.4.1 URL 문자 집합

- 컴퓨터 시스템의 기본 문자 집합은 보통 영어 중심으로 설정되어 있다.
- 7비트를 사용하여 영문 자판에 있는 키 대부분과 몇몇 출력되지 않는 제어 문자를 표현한다.
- URL이 특정 이진 데이터를 포함해야 하는 경우도 있다. 이를 위해 이스케이프 문자열을 쓸 수 있게 설계하였다.

### 2.4.2 인코딩 체계

- 안전한 문자 집합을 이용하는 경우 한계를 넘기 위해, URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안되었다.

---

## 인코딩된 문자 예

| **문자**       | **ASCII 코드** | **URL의 예**                                           |
| -------------- | -------------- | ------------------------------------------------------ |
| `~`            | 126 (0x7E)     | `http://www.joes-hardware.com/%7Ejoe`                  |
| 빈 문자 (공백) | 32 (0x20)      | `http://www.joes-hardware.com/more%20tools.html`       |
| `%`            | 37 (0x25)      | `http://www.joes-hardware.com/100%25satisfaction.html` |

---

### 2.4.3 문자 제한

- 몇몇 문자는 URL 내에서 특별한 의미로 **예약(reserved)** 되어 있다. 예: `%`, `$`, `+`, `@` 등.
- 또한 US-ASCII의 출력 가능한 문자 집합에 포함되지 않는 문자는 직접 사용할 수 없다.

### 2.4.4 좀 더 알아보기 (URL 인코딩 핵심)

- 일부 특수문자는 URL에 직접 써도 동작할 수 있으나, 애플리케이션·브라우저마다 해석 방식이 달라 **호환성 문제가 발생**할 수 있다.
- **가장 안전한 방법은 모든 안전하지 않은 문자를 표준대로 인코딩하는 것**.

---

## 2.5 스킴의 바다

### 주요 URL 스킴 정리

| **스킴**        | **설명**                                                      | **기본 포트**  | **예시**                                               |
| --------------- | ------------------------------------------------------------- | -------------- | ------------------------------------------------------ |
| **http**        | 하이퍼텍스트 전송 프로토콜. 웹 문서 전송에 사용.              | 80             | `http://www.joes-hardware.com/index.html`              |
| **https**       | 보안 전송(SSL/TLS). HTTP를 암호화하여 안전한 통신 제공.       | 443            | `https://www.joes-hardware.com/secure.html`            |
| **mailto**      | 이메일 주소를 가리킴. 이메일 클라이언트를 호출.               | 없음           | `mailto:joe@joes-hardware.com`                         |
| **ftp**         | 파일 전송 프로토콜. FTP 서버에서 파일 업/다운로드.            | 21             | `ftp://anonymous@joes-hardware.com/pub/gnu`            |
| **rtsp, rtspu** | 실시간 스트리밍 프로토콜. 미디어 스트리밍 전송.               | 554            | `rtsp://www.joes-hardware.com:554/interview.cto_video` |
| **file**        | 로컬 파일 경로. OS 파일 시스템 내 자원에 접근.                | 없음           | `file:///C:/OFFICE/SC/policies/casual-fridays.doc`     |
| **news**        | 뉴스 그룹 기사에 접근. (Usenet 기반)                          | 없음           | `news:comp.infosystems.www.servers.unix`               |
| **telnet**      | 원격 로그인 세션. 원격 서버에 접속해 터미널 사용. (보안 취약) | 23             | `telnet://slurp.webhound@joes-hardware.com/`           |
| **tel**         | 전화 링크 (모바일에서 사용) -> 책에서는 없었지만 추가         | 핸드폰 내 사용 | `tel:010-1234-5678`                                    |

---

⸻

📖 2025년 9월 27일 — 2.6 미래 & 3장 HTTP 메시지

⸻

## 2.6 미래

- URL은 강력한 도구다. URL은 세상에 존재하는 모든 객체에 이름을 지을 수 있고, 새로운 포맷을 쉽게 추가할 수 있게 설계됐다.
- 하지만 URL이 완벽한 것은 아니다. 사실 URL은 주소이지 실제 이름은 아니다.  
  → URL은 특정 시점에 어떠한 것이 위치한 곳을 알려준다는 것을 뜻한다.
- 인터넷 기술 테스크 포스(IETF)는 URN이라는 새로운 표준 작업에 착수하였다.
- URN은 객체가 옮겨지더라도 (웹 서버 내/간 모두) 항상 객체를 가리킬 수 있는 이름을 제공한다.
- 지속 통합 자원 지시자(PURL)을 사용하면 URL로 URN의 기능을 제공할 수 있다.
  - 클라이언트는 위치 할당자에게 리소스를 가져올 수 있는 영구적인 URL을 요청할 수 있으며, 영구적인 URL은 클라이언트를 리소스의 실제 URL로 연결해준다.

### 2.6.1 지금이 아니면, 언제?

- 한동안 URN 방식이 활용되었었다.
  - 그 명세들의 출시 날짜를 보면, 왜 아직 채택되지 않았는지 의문이 생긴다.
  - 현재도 채택되지 않은 것 같다. (2025년 9월 27일 기준)
- URL에서 URN으로 주소 체계를 바꾸는 것은 매우 큰 작업이다.
- 표준화는 중요할수록 느리게 진행된다.
- 표준 제정과 더불어 HTTP 애플리케이션을 수정해야 하는 벤더들과의 합의가 필요하다.
- URL은 현재는 물론 가까운 미래에도 인터넷 리소스 명명 방법으로 쓰일 것이다.
- URL은 한계를 가진 상태에서, 이를 해결할 새로운 표준(URN 등)이 나와 적용될 수 있다.

---

## 3장 HTTP 메시지

HTTP가 인터넷의 배달원이라면, **HTTP 메시지**는 무언가를 담아 보내는 **소포**와 같다.

1장에서 다룬 것처럼, HTTP 프로그램은 메시지를 주고받으며 동작한다.

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드들)
- 응답 메시지가 반환하는 여러 상태 코드
- 여러 HTTP 헤더의 역할

---

### 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받는 데이터 블록이다.  
이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.

- **인바운드 / 아웃바운드**: 메시지의 방향을 표현하는 용어
- **업스트림 / 다운스트림**: 송신자와 수신자의 상대적 방향을 표현하는 용어

#### 3.1.1 인바운드 / 아웃바운드

- 메시지가 원 서버로 향하면 **인바운드**
- 처리 후 사용자 에이전트로 돌아오면 **아웃바운드**

#### 3.1.2 다운스트림

- HTTP 메시지는 항상 **다운스트림**으로 흐른다.
- 요청/응답 관계없이, 발송자는 수신자의 **업스트림**이다.

---

### 3.2 메시지의 각 부분

- HTTP 메시지는 단순한 데이터 블록이지만, **구조화**되어 있다.
- 구성 요소:

  1. **시작줄**: 어떤 메시지인지 설명
  2. **헤더 블록**: 속성 정보
  3. **본문**: 데이터 (없을 수도 있음)

- 시작줄과 헤더:
  - 아스키 문자열
  - 줄 단위 구분, 각 줄 끝은 `CRLF` (`\r\n`)
- 본문:
  - 선택적 데이터 덩어리
  - 텍스트 또는 이진 데이터 포함 가능
  - 비어있을 수도 있음
- 주요 헤더:
  - `Content-Type`: 본문 데이터의 타입
  - `Content-Length`: 본문 크기

⸻

📖 2025년 9월 29일 — 3.2 HTTP 메시지 문법 정리

⸻

## 3.2.1 메시지 문법

- 모든 HTTP 메시지는 **요청(Request)** 또는 **응답(Response)** 으로 분류된다.
- 요청: 서버에 동작 요구 / 응답: 처리 결과 반환
- 구조는 기본적으로 동일

### 요청 메시지 형식

<메서드> <요청 URL> <버전>
<헤더들>

<엔터티 본문>

### 응답 메시지 형식

<버전> <상태 코드> <사유 구절>
<헤더들>

<엔터티 본문>

---

## 메시지 구성 요소

- **메서드**: 클라이언트가 원하는 동작 (예: GET, POST)
- **요청 URL**: 대상 리소스 (절대/상대 경로)
- **버전**: 사용 HTTP 버전 (예: HTTP/1.1)
- **상태 코드**: 요청 처리 결과를 설명하는 3자리 숫자
- **사유 구절(Reason Phrase)**: 상태 코드의 의미를 사람이 이해할 수 있게 설명
- **헤더들**: `이름: 값` 형식, CRLF로 구분, 빈 줄 이후 본문 시작
- **엔터티 본문**: 실제 데이터 (없을 수도 있음)

---

## 3.2.2 시작줄 (Start Line)

- 요청 메시지 → `메서드 + 요청 URL + HTTP 버전`
- 응답 메시지 → `HTTP 버전 + 상태 코드 + 사유 구절`

---

## HTTP 메서드 정리

| 메서드  | 설명               | 본문 유무 |
| ------- | ------------------ | --------- |
| GET     | 문서 가져오기      | 없음      |
| HEAD    | 헤더만 가져오기    | 없음      |
| POST    | 서버에 데이터 전송 | 있음      |
| PUT     | 콘텐츠 저장        | 있음      |
| TRACE   | 경로 추적          | 없음      |
| OPTIONS | 지원 메서드 확인   | 없음      |
| DELETE  | 문서 삭제          | 없음      |

---

## HTTP 상태 코드 (최신 확장)

| 범위    | 주요 코드                                                                                                                                                                                                                | 분류            | 설명                                  |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------- | ------------------------------------- |
| 100–199 | 100 Continue, 101 Switching Protocols, 103 Early Hints                                                                                                                                                                   | 정보            | 요청 진행, 프로토콜 전환              |
| 200–299 | 200 OK, 201 Created, 204 No Content, 206 Partial Content                                                                                                                                                                 | 성공            | 요청 성공                             |
| 300–399 | 301 Moved Permanently, 302 Found, 303 See Other, 307 Temporary Redirect, 308 Permanent Redirect                                                                                                                          | 리다이렉션      | 위치 변경                             |
| 400–499 | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 405 Method Not Allowed, 408 Timeout, 409 Conflict, 410 Gone, 413 Payload Too Large, 415 Unsupported Media Type, 418 I'm a teapot, 429 Too Many Requests | 클라이언트 에러 | 요청 오류, 권한 문제, Rate Limit 초과 |
| 500–599 | 500 Internal Server Error, 501 Not Implemented, 502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout, 507 Insufficient Storage, 511 Network Authentication Required                                             | 서버 에러       | 서버 장애, 게이트웨이 오류 등         |

> **600 이상**: HTTP 표준에는 없음. 다른 프로토콜(SIP)이나 벤더에서 비공식적으로 정의하는 경우 존재.

---

## 사유 구절 (Reason Phrase)

- 상태 코드의 의미를 짧게 설명하는 문자열
- 예: `200 OK` → OK는 사유 구절
- 상태 코드는 숫자가 우선, 사유 구절은 참고용

---

## 버전 번호

- 형식: `HTTP/x.y`
- 요청/응답 메시지에 모두 포함
- 애플리케이션이 지원하는 프로토콜 버전을 알림
- 예: HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3

⸻

📖 2025년 9월 30일 — HTTP 메시지 헤더, 엔티티, 메서드 정리

⸻

## 3.2.3 헤더

- 요청/응답의 시작줄 다음에는 **헤더(Header)** 들이 온다.
- HTTP 헤더는 필드 이름, 콜론(:), 값, CRLF 로 구성된다.
- 종류:
  - **일반 헤더(General)**: 요청/응답 모두 사용
  - **요청 헤더(Request)**: 요청 관련 부가 정보
  - **응답 헤더(Response)**: 응답 관련 부가 정보
  - **엔티티 헤더(Entity)**: 본문 크기/콘텐츠/리소스를 설명
  - **확장 헤더(Extension)**: 명세에 정의되지 않은 사용자 정의 헤더
- 긴 헤더는 여러 줄로 나눌 수 있으며, 추가 줄 앞에는 공백이나 탭 필요.

**예시**

HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
Version 1.0

→ `Server` 헤더는 여러 줄로 나뉘어 있지만, 최종 값은 `Test Server Version 1.0`

---

## 3.2.4 엔티티 본문

- HTTP 메시지의 세 번째 부분 = **엔티티 본문(Entity Body)**
- 메시지의 화물(payload)로 다양한 디지털 데이터를 실을 수 있음.
  - 예: 이미지, 비디오, HTML 문서, 애플리케이션, 이메일, 결제 트랜잭션 등
- 모든 메시지가 본문을 갖는 것은 아님 (예: GET 응답에서 `204 No Content`).

---

## 3.2.5 HTTP/0.9 메시지

- HTTP의 초기 버전 → 매우 단순
- 요청: `GET <경로>` 형식만 지원
- 응답: **엔티티만 반환** (헤더, 버전, 상태 코드 없음)

**예시**

클라이언트 → GET /specials/saw-blade.gif → 서버
서버 → 이미지 자체만 반환 → 클라이언트

- 기능이 지나치게 제한적이라 현대 웹에는 부적합.

---

## 3.3 메서드

- 모든 서버가 모든 메서드를 구현하는 것은 아님.
- HTTP/1.1 호환 최소 조건: **GET, HEAD** 지원
- 메서드에 따라 동작 범위와 의미가 다름.

### 3.3.1 안전한 메서드 (Safe Methods)

- **GET, HEAD**는 안전한 메서드 → 서버 상태를 바꾸지 않고 조회만 수행.
- 단, 보장은 아님 (개발자 구현에 따라 달라질 수 있음).

---

### 3.3.2 GET

- 가장 많이 쓰이는 메서드.
- 서버에서 리소스를 가져올 때 사용.
- 응답: 헤더 + 엔티티 본문.

---

### 3.3.3 HEAD

- GET과 동일하지만 **본문은 제외**하고 헤더만 반환.
- 활용:
  - 리소스 존재 여부 확인 (상태 코드)
  - 리소스 변경 여부 확인 (헤더 검사)
- 서버는 HEAD 응답 헤더가 GET과 정확히 일치하도록 보장해야 함.
- HTTP/1.1 서버는 반드시 HEAD 메서드를 구현해야 함.

**HEAD 요청/응답 예시**

요청:
HEAD /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: \*

응답:
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 617

→ 엔티티 본문은 없음

⸻

# 📖 2025년 10월 1일 — HTTP 메서드 & 상태 코드 정리

⸻

## 3.3 메서드

- 모든 서버가 모든 메서드를 구현하지는 않음.
- HTTP/1.1 호환을 위해서는 **GET, HEAD**만 구현해도 충분.
- 메서드는 크게 안전한 메서드(Safe)와 그렇지 않은 메서드로 구분됨.

---

### 3.3.4 PUT

- GET이 서버에서 읽어오는 반면, **PUT은 서버에 문서를 작성**.
- 요청 본문 → 요청 URL 이름의 문서를 생성하거나 교체.
- 보안상, 서버가 PUT 허용 시 보통 인증 요구.

---

### 3.3.5 POST

- 서버에 입력 데이터를 전송.
- **HTML 폼 전송**에서 가장 많이 쓰임.
- 서버가 받은 데이터를 게이트웨이/DB/프로그램 등에 전달.

  **POST 예시**

[클라이언트 요청]
POST /inventory-check.cgi HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-Length: 18

item=bandsaw 2647

[서버 처리]
→ CGI 프로그램 실행
→ “item=bandsaw 2647” 확인
→ 재고 DB 조회

[응답]
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 37

The bandsaw model 2647 is in stock!

---

### 3.3.6 TRACE

- 클라이언트 요청이 방화벽·프락시·게이트웨이 등을 거칠 때,  
  **요청이 어떻게 변형되었는지 추적/진단**.
- 디버깅용으로 사용.
- 엔티티 본문은 포함 불가.

---

### 3.3.7 OPTIONS

- 서버가 지원하는 **메서드 종류 확인**.
- 특정 리소스에 대해 어떤 동작을 허용하는지 질의.

---

### 3.3.8 DELETE

- 서버에 리소스 삭제 요청.
- **성공 보장 없음** (서버가 무시할 수도 있음).
- 실무에서는 보통 Response에 결과 반환.

---

### 3.3.9 확장 메서드 (WebDAV 등)

- HTTP는 확장 가능 설계 → 새로운 메서드 추가해도 호환 문제 없음.
- WebDAV 확장 메서드 예시:

| 메서드    | 설명                                              |
| --------- | ------------------------------------------------- |
| **LOCK**  | 리소스를 잠금 (다른 사용자가 동시에 수정 못하게). |
| **MKCOL** | 새 컬렉션(디렉토리) 생성.                         |
| **COPY**  | 리소스 복사.                                      |
| **MOVE**  | 리소스 이동.                                      |

---

## 3.4 상태 코드

- HTTP 상태 코드는 크게 5종류:
  - **1xx** 정보
  - **2xx** 성공
  - **3xx** 리다이렉션
  - **4xx** 클라이언트 오류
  - **5xx** 서버 오류
- 숫자 코드 + 사유 구절(reason phrase)로 구성.

---

### 3.4.1 100~199: 정보성 상태 코드

| 상태 코드 | 사유 구절           | 의미                                                                                            |
| --------- | ------------------- | ----------------------------------------------------------------------------------------------- |
| **100**   | Continue            | 요청 시작 부분 수신됨. 클라이언트는 나머지 본문 계속 전송. (`Expect: 100-continue`와 함께 사용) |
| **101**   | Switching Protocols | 클라이언트 `Upgrade` 헤더에 따라 서버가 프로토콜 변경.                                          |

**100 Continue 요약**

- **클라이언트**: 대용량 본문 보내기 전에 `Expect: 100-continue` 보냄 → 서버 허가 시 본문 전송.
- **서버**: 허용 시 `100 Continue`, 거절 시 최종 응답(400/401 등).
- **프록시**: 중간에서 해석 가능. 미지원 시 `417 Expectation Failed`.  
  → 목적: **불필요한 데이터 전송 방지**.

---

### 3.4.2 200~299: 성공 상태 코드

| 상태 코드 | 사유 구절                     | 의미                                                                  |
| --------- | ----------------------------- | --------------------------------------------------------------------- |
| **200**   | OK                            | 요청 정상 처리, 본문 포함.                                            |
| **201**   | Created                       | 새 리소스 생성됨. `Location` 헤더에 URI 포함.                         |
| **202**   | Accepted                      | 요청 접수, 처리 완료는 아님 (비동기).                                 |
| **203**   | Non-Authoritative Information | 원본이 아닌 중간 캐시/프록시가 제공한 데이터.                         |
| **204**   | No Content                    | 성공했으나 본문 없음 (예: 폼 제출 후 새 문서 필요 X).                 |
| **205**   | Reset Content                 | 성공 후, 클라이언트 입력 폼 초기화 필요.                              |
| **206**   | Partial Content               | 리소스 일부만 반환 (`Range` 요청). 다운로드 이어받기/스트리밍에 사용. |

---

### 3.4.3 300~399: 리다이렉션 상태 코드

| 상태 코드 | 사유 구절          | 의미                                                     |
| --------- | ------------------ | -------------------------------------------------------- |
| **300**   | Multiple Choices   | 여러 리소스 중 하나 선택 필요.                           |
| **301**   | Moved Permanently  | 리소스가 영구적으로 새 위치로 이동.                      |
| **302**   | Found              | 임시적으로 다른 URL에서 제공. (원래 URL 사용 가능)       |
| **303**   | See Other          | 다른 URL에서 가져와야 함 (주로 POST → GET 리다이렉트).   |
| **304**   | Not Modified       | 캐시된 버전 사용 가능 (If-Modified-Since, ETag).         |
| **305**   | Use Proxy          | 지정 프록시를 통해 접근해야 함 (현재는 거의 사용 안 함). |
| **306**   | (사용되지 않음)    | 과거 예약 코드.                                          |
| **307**   | Temporary Redirect | 302와 동일하지만 요청 메서드 그대로 유지.                |
| **308**   | Permanent Redirect | 301과 동일하지만 요청 메서드 그대로 유지.                |

---

**리다이렉션 차이 정리**

- **302**: 임시 이동 (브라우저가 POST → GET으로 바꿔버리기도 함).
- **303**: 반드시 GET으로 요청 다시 보내야 함.
- **307**: 메서드 유지한 채 임시 이동.
- **308**: 메서드 유지한 채 영구 이동.

⸻
