# HTTP 완벽 가이드 (HTTP: The Definitive Guide)

- HTTP를 이해하는 것이 중요한가?
  - 월드와이드 웹을 지탱하는 가장 중요한 기술 두 가지는 HTML과 HTTP이다. 이 두 기술은 팀버너스-리가 웹을 발명할 때 함께 만들어졌다.
  - 이 둘 중 하나라도 빠지면 웹은 성립하지 않으며, 한편으로 이 둘만 있어도 어떻게든 웹은 성립할 수 있다.
- HTTP를 이해한다는 것은 웹이 어떻게 동작하는지 이해한다는 것이며, 이를 깊이 이해하면 웹 프로그래밍을 하면서, 웹 서버를 조작하면서, 그리고 네트워크를 관리하면서 정확한 근거에 기반한 올바른 기술적 판단을 내려야 할 때 큰 도움이 된다.

## 1. HTTP

- 신뢰성 있는 데이터 전송 프로토콜을 사용하기 때문에 전송 중 손상되거나 꼬이지 않음을 보장한다.

### 1.2 웹클라이언트 서버

- 클라이언트 요청 → 서버 확인 → 서버 응답 → 클라이언트 화면 노출

### 1.3 리소스

- 웹 서버는 웹 리소스를 관리하고 제공한다 → 정적파일, 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수 있다. (동적 콘텐츠)

#### 1.3.1 미디어 타입

- 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME 타입이라는 데이터 포맷 라벨을 붙인다.

  - MIME (Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장) → 긴 문장으로는 처음 알았다…
  - 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었다.
  - 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다.

- 예시
  - HTML 작성된 문서: `text/html`
  - plain ASCII 텍스트: `text/plain`
  - JPEG 이미지: `image/jpeg`
  - GIF 이미지: `image/gif`
  - 애플 퀵타임 동영상: `video/quicktime`

#### 1.3.3 URI

- 서버 리소스 이름은 통합 자원 식별자
  - (uniform resource identifier) 혹은 URI
  - URI는 인터넷의 운편물 주소 같은 것으로, 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.
  - URI에는 두 가지가 있다. URL, URN

#### 1.3.3 URL

- 통합 자원 지시자(uniform resource locator, URL)는 리소스 식별자의 가장 흔한 형태다.
- URL은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.

| **URL**                                                      | **설명**                                                                     |
| ------------------------------------------------------------ | ---------------------------------------------------------------------------- |
| http://www.oreilly.com/index.html                            | 오라일리 출판사 홈페이지의 URL                                               |
| http://www.yahoo.com/images/logo.gif                         | 야후 웹 사이트 로고의 URL                                                    |
| http://www.joes-hardware.com/inventory-check.cgi/item=12731  | 물품 #12731의 재고가 있는지 확인하는 프로그램에 대한 URL                     |
| ftp://joetools:4u8f@ftp.joes-hardware.com/locking-pliers.gif | 비밀번호로 보호되는 FTP를 통해 locking-pliers.gif 이미지 파일에 접근하는 URL |

#### 1.3.4 URN

- URI의 두 번째 종류는 유니폼 리소스 이름(uniform resource name, URN)이다.
- URN은 콘텐츠를 이루는 한 리소스에 대해 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 한다.

### 1.4 트랜잭션

- 클라이언트가 웹 서버와 리소스를 주고 받기 위해 HTTP를 어떻게 사용하는지 자세하게 알아보면 아래와 같다.
  - HTTP 메시지라고 불리는 정형화된 데이터 덩어리를 이용해 이뤄진다.

#### 1.4.1 메서드

- HTTP는 HTTP 메서드라고 불리는 여러 가지 종류 요청 명령을 지원한다.
- 모든 HTTP 요청 메시지는 한 개의 메서드를 갖는다.
- 흔히 쓰이는 HTTP 메서드 다섯 개를 열거하고 있다.
  - GET, PUT, DELETE, POST, HEAD
    - **개인적으로 느꼈을 때 REST API에서 사용하는 대표적인 4가지 메서드는 GET, POST, PUT, DELETE이다. (상황에 따라 PATCH도 추가로 사용된다.)**

#### 1.4.2 상태코드

- 모든 HTTP 응답 메시지는 상태 코드와 함께 반환된다.
- 상태 코드는 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세 자리 숫자다.
  - 200(정상), 302(리디렉션, 임시이동), 404(없음)

### 1.6 TCP커넥션

#### 1.6.1 TCP/IP

- HTTP는 애플리케이션 계층 프로토콜이다. HTTP 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않는다.
- 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에 맡긴다.
  - “오류 없는 데이터 전송” → TCP의 **체크섬 + ACK/재전송**
  - “순서에 맞는 전달” → TCP의 **시퀀스 번호**
  - “조각나지 않는 데이터 스트림” → TCP가 스트림 단위로 연결을 유지 (IP 단편화와 무관하게 상위 레벨에서 연속된 바이트 스트림 제공)

| 계층              | 프로토콜 / 구성요소      | 설명                                                |
| ----------------- | ------------------------ | --------------------------------------------------- |
| 애플리케이션 계층 | HTTP                     | 웹 애플리케이션 통신 담당                           |
| 전송 계층         | TCP                      | 신뢰성 있는 데이터 전송 보장 (순서, 무결성, 재전송) |
| 네트워크 계층     | IP                       | 패킷을 목적지까지 전달 (주소 지정, 라우팅)          |
| 데이터 링크 계층  | 네트워크 인터페이스      | 네트워크 하드웨어와 상호작용, 프레임 단위 전송      |
| 물리 계층         | 물리적 네트워크 하드웨어 | 전기적/광학적 신호를 실제로 송수신                  |

#### 1.6.2 접속, IP 주소 그리고 포트번호

- HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜 (IP) 주소와 포트 번호를 사용해 클라이언트 사이에 TCP/IP 커넥션을 맺어야 한다.
- HTTP 80과 HTTPS 443만 일단 알고 있어도 충분 여기서는..
  - 21 FTP, 22 SSH, 23 TELNET 는 알고 있으면 좋다.
  - 53는 Router 53으로 AWS에서 쓰고 있는 것으로 기억하면 좋다.

## 웹 브라우저가 문서를 가져오는 과정

| 단계 | 설명                                                               |
| ---- | ------------------------------------------------------------------ |
| (a)  | 웹 브라우저는 서버의 URL에서 **호스트명**을 추출한다.              |
| (b)  | 웹 브라우저는 추출한 **호스트명을 IP 주소로 변환(DNS 조회)** 한다. |
| (c)  | 웹 브라우저는 URL에서 **포트 번호**(있다면)를 추출한다.            |
| (d)  | 웹 브라우저는 웹 서버와 **TCP 커넥션**을 맺는다.                   |
| (e)  | 웹 브라우저는 서버에 **HTTP 요청**을 보낸다.                       |
| (f)  | 서버는 브라우저에 **HTTP 응답**을 돌려준다.                        |
| (g)  | 커넥션이 닫히면, 브라우저는 **문서를 화면에 렌더링**한다.          |

### 1.7 프로토콜 버전

- 책에서는 프로토콜 버전으로 0.9부터 2.0까지만 나와있지만 현재는 3.0까지 존재한다. (책이 14년에 나왔으므로..)
- [inpa 블로그 - HTTP/3 통신 기술](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-30-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
- [Wikipedia - HTTP/3](https://en.wikipedia.org/wiki/HTTP/3)

## 1.8 웹의 구성요소

### 1.8.1 프락시

- 웹 보안, 애플리케이션 통합, 성능 최적화를 위해 사용되는 **옵션 구성요소** (예: Nginx, HAProxy, CloudFront)
- 클라이언트와 서버 사이에 위치해 모든 HTTP 요청을 받아 서버로 전달한다.
- 주로 **보안 목적**으로 쓰이며, 신뢰할 수 있는 중개자 역할을 한다.
- 요청과 응답을 **필터링**할 수 있다. (예: SSL 종료, 접근 제어, 광고/악성 요청 차단)
- **효과**: 보안 강화, 트래픽 관리(로드밸런싱, 캐싱, 압축), 서비스 안정성 확보

---

### 1.8.2 캐시

- 캐시 프락시는 프락시의 한 형태로, 자주 요청되는 문서의 **사본을 저장**한다.
- 동일한 요청이 들어오면 서버 대신 캐시에서 응답한다.
- **효과**: 네트워크 비용 절감, 응답 속도 향상, 서버 부하 감소

---

### 1.8.3 게이트웨이

- 다른 서버들의 중개자로 동작하는 특별한 서버
- 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용한다.
- 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다.
  - 예: HTTP/FTP 게이트웨이 → FTP URI에 대한 HTTP 요청을 받아들여, FTP 프로토콜을 통해 문서를 가져온다.

---

### 1.8.4 터널

- 두 커넥션 사이에서 데이터를 열어보지 않고 그대로 전달하는 HTTP 애플리케이션
- 대표적인 예: 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송하여, **웹 트래픽만 허용하는 방화벽**을 통과시키는 방식
- HTTP/SSL 터널은 HTTP 요청을 받아 목적지 주소와 포트번호로 커넥션을 맺는다.

---

### 1.8.5 에이전트

- 사용자를 대신해 HTTP 요청을 만드는 클라이언트 프로그램
- 모든 웹 요청 애플리케이션은 HTTP 에이전트
  - 예: 구글봇, AI 관련 크롤러 (사람 개입 없이 콘텐츠를 가져옴)

---

## 1.9 시작의 끝

- 이 장에서는 HTTP가 **멀티미디어 전송 프로토콜**로서 수행하는 역할을 다뤘다.

⸻

📖 2025년 9월 25일 — 2장 URL과 리소스 정리

⸻

2. URL과 리소스

책에서는 길거리 주소, 버스 노선 번호, 은행 계좌 같은 예시를 들며, **이름 체계(표준)**가 존재하기 때문에 리소스를 쉽게 공유할 수 있다고 설명한다.
• URL은 인터넷의 리소스를 가리키는 표준 이름이다.
• URL의 문법: 여러 컴포넌트가 어떤 의미를 가지며 무엇을 수행하는지 이해해야 한다.
• 상대 URI와 확장 URL: 여러 웹 클라이언트가 지원.
• URL의 인코딩과 문자 규칙
• 공통 URL 스킴: 여러 인터넷 정보 시스템에 적용.
• URN: 기존 이름을 유지하면서도 객체를 다른 장소로 옮길 수 있게 해주는 확장 개념.

⸻

2.1 인터넷의 리소스 탐색하기
• URL은 브라우저가 정보를 찾는 데 필요한 리소스의 위치를 가리킨다.
• URL을 통해 사람과 애플리케이션은 인터넷상의 수십억 개 리소스를 찾고, 사용하며, 공유할 수 있다.
• URL은 HTTP뿐 아니라 다른 프로토콜을 통해서도 접근 가능하다.
• 사용자는 브라우저에 URL을 입력하고, 브라우저는 뒤에서 적절한 프로토콜을 사용해 요청을 전송한다.

예시
• http://www.host/sasonal/index.html → 스킴 + 도메인 + 경로
• mailto:president@test.com → 메일 전송 프로토콜
• ftp://ftp.도메인/pub/test.xls → FTP 서버 파일
• rtsp://도메인:포트/cto_video → 스트리밍 영상

⸻

2.1.1 URL 이전의 암흑의 시대

웹과 URI가 등장하기 전에는 애플리케이션마다 다른 방식으로 리소스를 분류하고 접근해야 했다.
• 현재: URL/URI를 통해 통합된 방식으로 접근
• 과거: 서비스별 독자적 접근 방식
• FTP: 호스트명 + 포트 + 디렉토리 구조 필요
• Usenet 뉴스 그룹: 그룹명 + 기사 ID
• Telnet: 특정 포트 접속 후 커맨드 입력
• 로컬 DB: 쿼리나 고유 키 필요

⸻

2.2 URL 컴포넌트

| **컴포넌트**      | **설명**                                              | **기본값**       |
| ----------------- | ----------------------------------------------------- | ---------------- |
| **스킴**          | 리소스를 가져오기 위한 프로토콜                       | 없음             |
| **사용자 이름**   | 리소스 접근 시 필요한 사용자 이름                     | anonymous        |
| **비밀번호**      | 사용자 이름과 함께 쓰이는 인증 수단 (거의 사용 안 함) | 없음             |
| **호스트**        | 리소스를 가진 장비의 이름이나 IP 주소                 | 없음             |
| **포트**          | 서버가 열어둔 네트워크 포트                           | 스킴에 따라 다름 |
| **경로**          | 서버 내 리소스 위치                                   | 없음             |
| **파라미터**      | 리소스에 전달하는 이름/값 쌍의 매개 변수              | 없음             |
| **질의어(Query)** | 데이터베이스 질의 등 요청 시 전달되는 문자열          | 없음             |
| **프래그먼트**    | 리소스 내부 특정 위치 지정 (#anchor)                  | 없음             |

예시
• 사용자 이름/비밀번호: ftp://username:password@ftp.example.com/file.txt
• 파라미터: http://example.com/content;lang=ko;version=2
• 질의어: https://www.google.com/search?q=nextjs+seo&hl=ko

⸻

2.2.1 URL 파라미터 (;param=value)
• 의미: 리소스 경로에 추가 속성을 전달하는 방식
• 등장 배경: 쿼리스트링(?)이나 쿠키가 보편화되기 전, HTTP 초창기에 사용됨
• 사례
• 리소스 옵션 지정: http://example.com/index.html;lang=ko;version=2
• 세션 식별자 전달: http://example.com/app/main;jsessionid=1234567890ABCDEF
• 현재
• 거의 사용되지 않음
• RESTful API, Query String, Header로 대체
• 레거시 Java 웹 서버(JSP/Servlet)에서 ;jsessionid 형태로 가끔 등장

⸻

2.3 단축 URL
• 상대 URL을 사용하면 리소스를 간결하게 기술 가능.
• 일부 브라우저/클라이언트는 사용자가 입력한 URL 일부를 기반으로 나머지를 자동 완성하기도 함.

⸻

2.3.1 상대 URL

1. 상대 URL (Relative URL)
   • 문서 내에서 ./hammers.html처럼 간단히 표현
   • 장점: 문서를 다른 서버/디렉토리로 옮겨도 상대 경로는 그대로 유지

예시:

<a href="./hammers.html">Hammers</a>

    •	기준(Base URL): http://www.joes-hardware.com/tools.html
    •	상대 URL: ./hammers.html
    •	절대 URL: http://www.joes-hardware.com/hammers.html

⸻

2. 기저 URL (Base URL)

상대 URL을 해석할 때 기준이 되는 URL.
• HTML 문서 자체 URL
• <base> 태그로 명시
• 리소스에서 암시적으로 제공되는 경우

⸻

3. 기저 URL이 없는 경우
   • 문서가 로컬 파일로만 제공되는 경우
   • 상대 URL 해석 불가 → 불완전 상태

⸻

4. 상대 경로 해석 규칙
   • ./, ../ 문법을 적용해 절대 경로로 변환

   • 예시:
   • 기저 URL: http://example.com/dir/tools.html
   • 상대 URL: ../images/icon.png
   • 절대 URL: http://example.com/images/icon.png

⸻

📖 2025년 9월 26일 — 2.4 안전하지 않은 문자 & 2.5 스킴 정리

⸻

## 2.4 안전하지 않은 문자

- URL은 잘 호환되도록 설계되었다.
- URL은 인터넷에 있는 모든 리소스가 여러 프로토콜을 통해서 전달될 수 있도록, 각 리소스에 유일한 이름을 지을 수 있게 설계되었다.
- SMTP(메일 프로토콜)는 특정 문자를 제거할 수도 있는 전송 방식을 사용한다.
- 문자가 제거되는 일을 피하고자 URL은 상대적으로 작고 일반적으로 안전한 알파벳 문자만 포함하도록 허락한다.
- 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게 하였다.

### 2.4.1 URL 문자 집합

- 컴퓨터 시스템의 기본 문자 집합은 보통 영어 중심으로 설정되어 있다.
- 7비트를 사용하여 영문 자판에 있는 키 대부분과 몇몇 출력되지 않는 제어 문자를 표현한다.
- URL이 특정 이진 데이터를 포함해야 하는 경우도 있다. 이를 위해 이스케이프 문자열을 쓸 수 있게 설계하였다.

### 2.4.2 인코딩 체계

- 안전한 문자 집합을 이용하는 경우 한계를 넘기 위해, URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안되었다.

---

## 인코딩된 문자 예

| **문자**       | **ASCII 코드** | **URL의 예**                                           |
| -------------- | -------------- | ------------------------------------------------------ |
| `~`            | 126 (0x7E)     | `http://www.joes-hardware.com/%7Ejoe`                  |
| 빈 문자 (공백) | 32 (0x20)      | `http://www.joes-hardware.com/more%20tools.html`       |
| `%`            | 37 (0x25)      | `http://www.joes-hardware.com/100%25satisfaction.html` |

---

### 2.4.3 문자 제한

- 몇몇 문자는 URL 내에서 특별한 의미로 **예약(reserved)** 되어 있다. 예: `%`, `$`, `+`, `@` 등.
- 또한 US-ASCII의 출력 가능한 문자 집합에 포함되지 않는 문자는 직접 사용할 수 없다.

### 2.4.4 좀 더 알아보기 (URL 인코딩 핵심)

- 일부 특수문자는 URL에 직접 써도 동작할 수 있으나, 애플리케이션·브라우저마다 해석 방식이 달라 **호환성 문제가 발생**할 수 있다.
- **가장 안전한 방법은 모든 안전하지 않은 문자를 표준대로 인코딩하는 것**.

---

## 2.5 스킴의 바다

### 주요 URL 스킴 정리

| **스킴**        | **설명**                                                      | **기본 포트**  | **예시**                                               |
| --------------- | ------------------------------------------------------------- | -------------- | ------------------------------------------------------ |
| **http**        | 하이퍼텍스트 전송 프로토콜. 웹 문서 전송에 사용.              | 80             | `http://www.joes-hardware.com/index.html`              |
| **https**       | 보안 전송(SSL/TLS). HTTP를 암호화하여 안전한 통신 제공.       | 443            | `https://www.joes-hardware.com/secure.html`            |
| **mailto**      | 이메일 주소를 가리킴. 이메일 클라이언트를 호출.               | 없음           | `mailto:joe@joes-hardware.com`                         |
| **ftp**         | 파일 전송 프로토콜. FTP 서버에서 파일 업/다운로드.            | 21             | `ftp://anonymous@joes-hardware.com/pub/gnu`            |
| **rtsp, rtspu** | 실시간 스트리밍 프로토콜. 미디어 스트리밍 전송.               | 554            | `rtsp://www.joes-hardware.com:554/interview.cto_video` |
| **file**        | 로컬 파일 경로. OS 파일 시스템 내 자원에 접근.                | 없음           | `file:///C:/OFFICE/SC/policies/casual-fridays.doc`     |
| **news**        | 뉴스 그룹 기사에 접근. (Usenet 기반)                          | 없음           | `news:comp.infosystems.www.servers.unix`               |
| **telnet**      | 원격 로그인 세션. 원격 서버에 접속해 터미널 사용. (보안 취약) | 23             | `telnet://slurp.webhound@joes-hardware.com/`           |
| **tel**         | 전화 링크 (모바일에서 사용) -> 책에서는 없었지만 추가         | 핸드폰 내 사용 | `tel:010-1234-5678`                                    |

---

⸻

📖 2025년 9월 27일 — 2.6 미래 & 3장 HTTP 메시지

⸻

## 2.6 미래

- URL은 강력한 도구다. URL은 세상에 존재하는 모든 객체에 이름을 지을 수 있고, 새로운 포맷을 쉽게 추가할 수 있게 설계됐다.
- 하지만 URL이 완벽한 것은 아니다. 사실 URL은 주소이지 실제 이름은 아니다.  
  → URL은 특정 시점에 어떠한 것이 위치한 곳을 알려준다는 것을 뜻한다.
- 인터넷 기술 테스크 포스(IETF)는 URN이라는 새로운 표준 작업에 착수하였다.
- URN은 객체가 옮겨지더라도 (웹 서버 내/간 모두) 항상 객체를 가리킬 수 있는 이름을 제공한다.
- 지속 통합 자원 지시자(PURL)을 사용하면 URL로 URN의 기능을 제공할 수 있다.
  - 클라이언트는 위치 할당자에게 리소스를 가져올 수 있는 영구적인 URL을 요청할 수 있으며, 영구적인 URL은 클라이언트를 리소스의 실제 URL로 연결해준다.

### 2.6.1 지금이 아니면, 언제?

- 한동안 URN 방식이 활용되었었다.
  - 그 명세들의 출시 날짜를 보면, 왜 아직 채택되지 않았는지 의문이 생긴다.
  - 현재도 채택되지 않은 것 같다. (2025년 9월 27일 기준)
- URL에서 URN으로 주소 체계를 바꾸는 것은 매우 큰 작업이다.
- 표준화는 중요할수록 느리게 진행된다.
- 표준 제정과 더불어 HTTP 애플리케이션을 수정해야 하는 벤더들과의 합의가 필요하다.
- URL은 현재는 물론 가까운 미래에도 인터넷 리소스 명명 방법으로 쓰일 것이다.
- URL은 한계를 가진 상태에서, 이를 해결할 새로운 표준(URN 등)이 나와 적용될 수 있다.

---

## 3장 HTTP 메시지

HTTP가 인터넷의 배달원이라면, **HTTP 메시지**는 무언가를 담아 보내는 **소포**와 같다.

1장에서 다룬 것처럼, HTTP 프로그램은 메시지를 주고받으며 동작한다.

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드들)
- 응답 메시지가 반환하는 여러 상태 코드
- 여러 HTTP 헤더의 역할

---

### 3.1 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받는 데이터 블록이다.  
이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.

- **인바운드 / 아웃바운드**: 메시지의 방향을 표현하는 용어
- **업스트림 / 다운스트림**: 송신자와 수신자의 상대적 방향을 표현하는 용어

#### 3.1.1 인바운드 / 아웃바운드

- 메시지가 원 서버로 향하면 **인바운드**
- 처리 후 사용자 에이전트로 돌아오면 **아웃바운드**

#### 3.1.2 다운스트림

- HTTP 메시지는 항상 **다운스트림**으로 흐른다.
- 요청/응답 관계없이, 발송자는 수신자의 **업스트림**이다.

---

### 3.2 메시지의 각 부분

- HTTP 메시지는 단순한 데이터 블록이지만, **구조화**되어 있다.
- 구성 요소:

  1. **시작줄**: 어떤 메시지인지 설명
  2. **헤더 블록**: 속성 정보
  3. **본문**: 데이터 (없을 수도 있음)

- 시작줄과 헤더:
  - 아스키 문자열
  - 줄 단위 구분, 각 줄 끝은 `CRLF` (`\r\n`)
- 본문:
  - 선택적 데이터 덩어리
  - 텍스트 또는 이진 데이터 포함 가능
  - 비어있을 수도 있음
- 주요 헤더:
  - `Content-Type`: 본문 데이터의 타입
  - `Content-Length`: 본문 크기

⸻

📖 2025년 9월 29일 — 3.2 HTTP 메시지 문법 정리

⸻

## 3.2.1 메시지 문법

- 모든 HTTP 메시지는 **요청(Request)** 또는 **응답(Response)** 으로 분류된다.
- 요청: 서버에 동작 요구 / 응답: 처리 결과 반환
- 구조는 기본적으로 동일

### 요청 메시지 형식

<메서드> <요청 URL> <버전>
<헤더들>

<엔터티 본문>

### 응답 메시지 형식

<버전> <상태 코드> <사유 구절>
<헤더들>

<엔터티 본문>

---

## 메시지 구성 요소

- **메서드**: 클라이언트가 원하는 동작 (예: GET, POST)
- **요청 URL**: 대상 리소스 (절대/상대 경로)
- **버전**: 사용 HTTP 버전 (예: HTTP/1.1)
- **상태 코드**: 요청 처리 결과를 설명하는 3자리 숫자
- **사유 구절(Reason Phrase)**: 상태 코드의 의미를 사람이 이해할 수 있게 설명
- **헤더들**: `이름: 값` 형식, CRLF로 구분, 빈 줄 이후 본문 시작
- **엔터티 본문**: 실제 데이터 (없을 수도 있음)

---

## 3.2.2 시작줄 (Start Line)

- 요청 메시지 → `메서드 + 요청 URL + HTTP 버전`
- 응답 메시지 → `HTTP 버전 + 상태 코드 + 사유 구절`

---

## HTTP 메서드 정리

| 메서드  | 설명               | 본문 유무 |
| ------- | ------------------ | --------- |
| GET     | 문서 가져오기      | 없음      |
| HEAD    | 헤더만 가져오기    | 없음      |
| POST    | 서버에 데이터 전송 | 있음      |
| PUT     | 콘텐츠 저장        | 있음      |
| TRACE   | 경로 추적          | 없음      |
| OPTIONS | 지원 메서드 확인   | 없음      |
| DELETE  | 문서 삭제          | 없음      |

---

## HTTP 상태 코드 (최신 확장)

| 범위    | 주요 코드                                                                                                                                                                                                                | 분류            | 설명                                  |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------- | ------------------------------------- |
| 100–199 | 100 Continue, 101 Switching Protocols, 103 Early Hints                                                                                                                                                                   | 정보            | 요청 진행, 프로토콜 전환              |
| 200–299 | 200 OK, 201 Created, 204 No Content, 206 Partial Content                                                                                                                                                                 | 성공            | 요청 성공                             |
| 300–399 | 301 Moved Permanently, 302 Found, 303 See Other, 307 Temporary Redirect, 308 Permanent Redirect                                                                                                                          | 리다이렉션      | 위치 변경                             |
| 400–499 | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 405 Method Not Allowed, 408 Timeout, 409 Conflict, 410 Gone, 413 Payload Too Large, 415 Unsupported Media Type, 418 I'm a teapot, 429 Too Many Requests | 클라이언트 에러 | 요청 오류, 권한 문제, Rate Limit 초과 |
| 500–599 | 500 Internal Server Error, 501 Not Implemented, 502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout, 507 Insufficient Storage, 511 Network Authentication Required                                             | 서버 에러       | 서버 장애, 게이트웨이 오류 등         |

> **600 이상**: HTTP 표준에는 없음. 다른 프로토콜(SIP)이나 벤더에서 비공식적으로 정의하는 경우 존재.

---

## 사유 구절 (Reason Phrase)

- 상태 코드의 의미를 짧게 설명하는 문자열
- 예: `200 OK` → OK는 사유 구절
- 상태 코드는 숫자가 우선, 사유 구절은 참고용

---

## 버전 번호

- 형식: `HTTP/x.y`
- 요청/응답 메시지에 모두 포함
- 애플리케이션이 지원하는 프로토콜 버전을 알림
- 예: HTTP/1.0, HTTP/1.1, HTTP/2, HTTP/3

⸻

📖 2025년 9월 30일 — HTTP 메시지 헤더, 엔티티, 메서드 정리

⸻

## 3.2.3 헤더

- 요청/응답의 시작줄 다음에는 **헤더(Header)** 들이 온다.
- HTTP 헤더는 필드 이름, 콜론(:), 값, CRLF 로 구성된다.
- 종류:
  - **일반 헤더(General)**: 요청/응답 모두 사용
  - **요청 헤더(Request)**: 요청 관련 부가 정보
  - **응답 헤더(Response)**: 응답 관련 부가 정보
  - **엔티티 헤더(Entity)**: 본문 크기/콘텐츠/리소스를 설명
  - **확장 헤더(Extension)**: 명세에 정의되지 않은 사용자 정의 헤더
- 긴 헤더는 여러 줄로 나눌 수 있으며, 추가 줄 앞에는 공백이나 탭 필요.

**예시**

HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
Version 1.0

→ `Server` 헤더는 여러 줄로 나뉘어 있지만, 최종 값은 `Test Server Version 1.0`

---

## 3.2.4 엔티티 본문

- HTTP 메시지의 세 번째 부분 = **엔티티 본문(Entity Body)**
- 메시지의 화물(payload)로 다양한 디지털 데이터를 실을 수 있음.
  - 예: 이미지, 비디오, HTML 문서, 애플리케이션, 이메일, 결제 트랜잭션 등
- 모든 메시지가 본문을 갖는 것은 아님 (예: GET 응답에서 `204 No Content`).

---

## 3.2.5 HTTP/0.9 메시지

- HTTP의 초기 버전 → 매우 단순
- 요청: `GET <경로>` 형식만 지원
- 응답: **엔티티만 반환** (헤더, 버전, 상태 코드 없음)

**예시**

클라이언트 → GET /specials/saw-blade.gif → 서버
서버 → 이미지 자체만 반환 → 클라이언트

- 기능이 지나치게 제한적이라 현대 웹에는 부적합.

---

## 3.3 메서드

- 모든 서버가 모든 메서드를 구현하는 것은 아님.
- HTTP/1.1 호환 최소 조건: **GET, HEAD** 지원
- 메서드에 따라 동작 범위와 의미가 다름.

### 3.3.1 안전한 메서드 (Safe Methods)

- **GET, HEAD**는 안전한 메서드 → 서버 상태를 바꾸지 않고 조회만 수행.
- 단, 보장은 아님 (개발자 구현에 따라 달라질 수 있음).

---

### 3.3.2 GET

- 가장 많이 쓰이는 메서드.
- 서버에서 리소스를 가져올 때 사용.
- 응답: 헤더 + 엔티티 본문.

---

### 3.3.3 HEAD

- GET과 동일하지만 **본문은 제외**하고 헤더만 반환.
- 활용:
  - 리소스 존재 여부 확인 (상태 코드)
  - 리소스 변경 여부 확인 (헤더 검사)
- 서버는 HEAD 응답 헤더가 GET과 정확히 일치하도록 보장해야 함.
- HTTP/1.1 서버는 반드시 HEAD 메서드를 구현해야 함.

**HEAD 요청/응답 예시**

요청:
HEAD /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: \*

응답:
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 617

→ 엔티티 본문은 없음

⸻

# 📖 2025년 10월 1일 — HTTP 메서드 & 상태 코드 정리

⸻

## 3.3 메서드

- 모든 서버가 모든 메서드를 구현하지는 않음.
- HTTP/1.1 호환을 위해서는 **GET, HEAD**만 구현해도 충분.
- 메서드는 크게 안전한 메서드(Safe)와 그렇지 않은 메서드로 구분됨.

---

### 3.3.4 PUT

- GET이 서버에서 읽어오는 반면, **PUT은 서버에 문서를 작성**.
- 요청 본문 → 요청 URL 이름의 문서를 생성하거나 교체.
- 보안상, 서버가 PUT 허용 시 보통 인증 요구.

---

### 3.3.5 POST

- 서버에 입력 데이터를 전송.
- **HTML 폼 전송**에서 가장 많이 쓰임.
- 서버가 받은 데이터를 게이트웨이/DB/프로그램 등에 전달.

  **POST 예시**

[클라이언트 요청]
POST /inventory-check.cgi HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-Length: 18

item=bandsaw 2647

[서버 처리]
→ CGI 프로그램 실행
→ “item=bandsaw 2647” 확인
→ 재고 DB 조회

[응답]
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 37

The bandsaw model 2647 is in stock!

---

### 3.3.6 TRACE

- 클라이언트 요청이 방화벽·프락시·게이트웨이 등을 거칠 때,  
  **요청이 어떻게 변형되었는지 추적/진단**.
- 디버깅용으로 사용.
- 엔티티 본문은 포함 불가.

---

### 3.3.7 OPTIONS

- 서버가 지원하는 **메서드 종류 확인**.
- 특정 리소스에 대해 어떤 동작을 허용하는지 질의.

---

### 3.3.8 DELETE

- 서버에 리소스 삭제 요청.
- **성공 보장 없음** (서버가 무시할 수도 있음).
- 실무에서는 보통 Response에 결과 반환.

---

### 3.3.9 확장 메서드 (WebDAV 등)

- HTTP는 확장 가능 설계 → 새로운 메서드 추가해도 호환 문제 없음.
- WebDAV 확장 메서드 예시:

| 메서드    | 설명                                              |
| --------- | ------------------------------------------------- |
| **LOCK**  | 리소스를 잠금 (다른 사용자가 동시에 수정 못하게). |
| **MKCOL** | 새 컬렉션(디렉토리) 생성.                         |
| **COPY**  | 리소스 복사.                                      |
| **MOVE**  | 리소스 이동.                                      |

---

## 3.4 상태 코드

- HTTP 상태 코드는 크게 5종류:
  - **1xx** 정보
  - **2xx** 성공
  - **3xx** 리다이렉션
  - **4xx** 클라이언트 오류
  - **5xx** 서버 오류
- 숫자 코드 + 사유 구절(reason phrase)로 구성.

---

### 3.4.1 100~199: 정보성 상태 코드

| 상태 코드 | 사유 구절           | 의미                                                                                            |
| --------- | ------------------- | ----------------------------------------------------------------------------------------------- |
| **100**   | Continue            | 요청 시작 부분 수신됨. 클라이언트는 나머지 본문 계속 전송. (`Expect: 100-continue`와 함께 사용) |
| **101**   | Switching Protocols | 클라이언트 `Upgrade` 헤더에 따라 서버가 프로토콜 변경.                                          |

**100 Continue 요약**

- **클라이언트**: 대용량 본문 보내기 전에 `Expect: 100-continue` 보냄 → 서버 허가 시 본문 전송.
- **서버**: 허용 시 `100 Continue`, 거절 시 최종 응답(400/401 등).
- **프록시**: 중간에서 해석 가능. 미지원 시 `417 Expectation Failed`.  
  → 목적: **불필요한 데이터 전송 방지**.

---

### 3.4.2 200~299: 성공 상태 코드

| 상태 코드 | 사유 구절                     | 의미                                                                  |
| --------- | ----------------------------- | --------------------------------------------------------------------- |
| **200**   | OK                            | 요청 정상 처리, 본문 포함.                                            |
| **201**   | Created                       | 새 리소스 생성됨. `Location` 헤더에 URI 포함.                         |
| **202**   | Accepted                      | 요청 접수, 처리 완료는 아님 (비동기).                                 |
| **203**   | Non-Authoritative Information | 원본이 아닌 중간 캐시/프록시가 제공한 데이터.                         |
| **204**   | No Content                    | 성공했으나 본문 없음 (예: 폼 제출 후 새 문서 필요 X).                 |
| **205**   | Reset Content                 | 성공 후, 클라이언트 입력 폼 초기화 필요.                              |
| **206**   | Partial Content               | 리소스 일부만 반환 (`Range` 요청). 다운로드 이어받기/스트리밍에 사용. |

---

### 3.4.3 300~399: 리다이렉션 상태 코드

| 상태 코드 | 사유 구절          | 의미                                                     |
| --------- | ------------------ | -------------------------------------------------------- |
| **300**   | Multiple Choices   | 여러 리소스 중 하나 선택 필요.                           |
| **301**   | Moved Permanently  | 리소스가 영구적으로 새 위치로 이동.                      |
| **302**   | Found              | 임시적으로 다른 URL에서 제공. (원래 URL 사용 가능)       |
| **303**   | See Other          | 다른 URL에서 가져와야 함 (주로 POST → GET 리다이렉트).   |
| **304**   | Not Modified       | 캐시된 버전 사용 가능 (If-Modified-Since, ETag).         |
| **305**   | Use Proxy          | 지정 프록시를 통해 접근해야 함 (현재는 거의 사용 안 함). |
| **306**   | (사용되지 않음)    | 과거 예약 코드.                                          |
| **307**   | Temporary Redirect | 302와 동일하지만 요청 메서드 그대로 유지.                |
| **308**   | Permanent Redirect | 301과 동일하지만 요청 메서드 그대로 유지.                |

---

**리다이렉션 차이 정리**

- **302**: 임시 이동 (브라우저가 POST → GET으로 바꿔버리기도 함).
- **303**: 반드시 GET으로 요청 다시 보내야 함.
- **307**: 메서드 유지한 채 임시 이동.
- **308**: 메서드 유지한 채 영구 이동.

⸻

📖 2025년 10월 1일 — HTTP 상태 코드 (클라이언트/서버 에러)

⸻

## 3.4.4 400~499: 클라이언트 에러 상태 코드

가끔 클라이언트는 서버가 다룰 수 없는 요청을 보낸다.  
대표적으로 존재하지 않는 URL 요청 시 `404 Not Found`가 발생한다.

---

### **HTTP 상태 코드: 400대 (클라이언트 오류)**

| 상태 코드 | 사유 구절                     | 의미                                            |
| --------- | ----------------------------- | ----------------------------------------------- |
| **400**   | Bad Request                   | 클라이언트가 잘못된 요청을 보냈음               |
| **401**   | Unauthorized                  | 인증 필요. 인증 정보가 없거나 잘못됨            |
| **402**   | Payment Required              | 결제 관련 기능을 위해 예약됨 (현재 거의 사용 X) |
| **403**   | Forbidden                     | 서버가 요청을 이해했으나 권한 문제로 거부       |
| **404**   | Not Found                     | 요청한 리소스를 찾을 수 없음                    |
| **405**   | Method Not Allowed            | 리소스가 해당 메서드를 지원하지 않음            |
| **406**   | Not Acceptable                | 서버가 요청한 응답 형식을 제공할 수 없음        |
| **407**   | Proxy Authentication Required | 프록시 인증 필요                                |
| **408**   | Request Timeout               | 요청 시간이 너무 길어 서버가 연결 종료          |
| **409**   | Conflict                      | 요청이 서버의 현재 상태와 충돌                  |
| **410**   | Gone                          | 리소스가 영구적으로 삭제됨                      |
| **411**   | Length Required               | Content-Length 헤더가 없어서 처리 불가          |
| **412**   | Precondition Failed           | 요청 조건이 서버 조건과 불일치                  |
| **413**   | Payload Too Large             | 요청 본문이 너무 커서 처리 불가                 |
| **414**   | URI Too Long                  | 요청 URI가 너무 김                              |
| **415**   | Unsupported Media Type        | 서버가 지원하지 않는 Content-Type               |
| **416**   | Range Not Satisfiable         | 잘못된 범위 요청 (Range 헤더 오류)              |
| **417**   | Expectation Failed            | Expect 헤더 조건 불만족                         |

---

**400대 핵심 요약**

- **400, 401, 403, 404, 405** → 가장 자주 보는 에러.
- **409, 412** → 버전/조건 충돌 관련.
- **406, 415, 416** → 헤더·형식 불일치 문제.
- **410 Gone** → 리소스가 완전히 삭제된 경우.

---

## 3.4.5 500~599: 서버 에러 상태 코드

때때로 올바른 요청이어도 서버 자체에서 에러가 발생한다.  
서버 과부하, 게이트웨이 문제, 미지원 기능 등이 원인일 수 있다.

---

### **HTTP 상태 코드: 500대 (서버 오류)**

| 상태 코드 | 사유 구절                  | 의미                                                    |
| --------- | -------------------------- | ------------------------------------------------------- |
| **500**   | Internal Server Error      | 서버 내부에서 일반적인 에러 발생                        |
| **501**   | Not Implemented            | 서버가 요청 기능/메서드를 지원하지 않음                 |
| **502**   | Bad Gateway                | 게이트웨이/프록시가 잘못된 응답을 받음                  |
| **503**   | Service Unavailable        | 서버 과부하/점검 중 (Retry-After로 재시도 안내 가능)    |
| **504**   | Gateway Timeout            | 게이트웨이/프록시가 상위 서버 응답을 기다리다 시간 초과 |
| **505**   | HTTP Version Not Supported | 서버가 요청에 사용된 HTTP 버전을 지원하지 않음          |

---

**500대 핵심 요약**

- **500**: 가장 흔한 서버 오류 (범용 에러).
- **502/504**: 게이트웨이·프록시 문제.
- **503**: 서버 과부하 or 점검.
- **501/505**: 서버 미지원 기능.

⸻

# 📖 2025년 10월 2일 — HTTP 헤더 정리 (엔티티 헤더 제외)

⸻

## 헤더의 5가지 분류

- 일반 헤더 (General Headers) → 요청/응답 모두 사용
- 요청 헤더 (Request Headers) → 요청 메시지 전용
- 응답 헤더 (Response Headers) → 응답 메시지 전용
- 엔티티 헤더 (Entity Headers) → 본문(엔티티)에 대한 메타정보
- 확장 헤더 (Extension Headers) → 비표준, 확장용

---

## 1. 일반 헤더 (General Headers)

| 헤더                       | 설명                                                   |
| -------------------------- | ------------------------------------------------------ |
| Connection                 | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정함  |
| Date                       | 메시지가 언제 만들어졌는지 (GMT 기준)                  |
| MIME-Version               | 발송자가 사용한 MIME 버전                              |
| Trailer (chunked transfer) | 인코딩된 메시지 끝에 위치한 메타정보 목록              |
| Transfer-Encoding          | 메시지에 적용된 인코딩 방식                            |
| Upgrade                    | 업그레이드할 새 버전/프로토콜 정보                     |
| Via                        | 메시지가 어떤 프록시/게이트웨이를 거쳐왔는지 경로 표시 |

### 캐시 관련 일반 헤더

| 헤더          | 설명                                               |
| ------------- | -------------------------------------------------- |
| Cache-Control | 캐시 정책(지시자) 전달                             |
| Pragma        | 오래된 캐시 지시자 (현재는 Cache-Control로 대체됨) |

---

## 2. 요청 헤더 (Request Headers)

### 클라이언트 식별

| 헤더       | 설명                                             |
| ---------- | ------------------------------------------------ |
| Client-IP  | 클라이언트가 실행된 컴퓨터의 IP를 제공 (비표준)  |
| From       | 클라이언트 사용자의 이메일 주소                  |
| Host       | 요청 대상 서버의 호스트명과 포트 (HTTP/1.1 필수) |
| Referer    | 현재 요청이 발생한 이전 문서의 URL               |
| UA-Color   | 디스플레이 색상 정보 (레거시)                    |
| UA-CPU     | CPU 종류 정보 (레거시)                           |
| UA-Disp    | 디스플레이 장치 특성 정보                        |
| UA-OS      | 운영체제 종류와 버전                             |
| UA-Pixels  | 화면 해상도 정보                                 |
| User-Agent | 요청을 보낸 애플리케이션의 이름과 버전           |

---

### 콘텐츠 협상 (Accept 관련)

| 헤더            | 설명                                            |
| --------------- | ----------------------------------------------- |
| Accept          | 서버가 보낼 수 있는 미디어 타입(MIME 타입) 지정 |
| Accept-Charset  | 서버가 보낼 수 있는 문자 집합 지정              |
| Accept-Encoding | 서버가 보낼 수 있는 인코딩 방식 지정            |
| Accept-Language | 서버가 보낼 수 있는 언어 지정                   |
| TE              | 서버가 보낼 수 있는 전송 인코딩 지정            |

---

### 조건부 요청

| 헤더                | 설명                                                 |
| ------------------- | ---------------------------------------------------- |
| Expect              | 서버에 원하는 동작을 알림 (예: Expect: 100-continue) |
| If-Match            | ETag가 일치할 때만 요청 수행                         |
| If-Modified-Since   | 지정된 날짜 이후 변경되었을 경우만 요청 수행         |
| If-None-Match       | ETag 불일치 시 요청 수행 (캐시 검증에 사용)          |
| If-Range            | 수정 없으면 범위만, 수정 있으면 전체 반환            |
| If-Unmodified-Since | 지정된 날짜 이후 변경되지 않았을 경우 요청 수행      |
| Range               | 문서의 일부(바이트 범위)만 요청                      |

---

### 보안 관련

| 헤더          | 설명                                                            |
| ------------- | --------------------------------------------------------------- |
| Authorization | 클라이언트가 서버에 제공하는 인증 정보 (Basic, Bearer Token 등) |
| Cookie        | 클라이언트가 보관 중인 세션/토큰을 서버로 전송                  |
| Cookie2       | 쿠키 버전 전달 (RFC 2965, 현재는 거의 사용되지 않음)            |

---

### 프락시 관련

| 헤더                | 설명                                              |
| ------------------- | ------------------------------------------------- |
| Max-Forwards        | 요청이 프락시/게이트웨이를 거칠 수 있는 최대 횟수 |
| Proxy-Authorization | 프락시 인증 정보 전달                             |
| Proxy-Connection    | 프락시 서버와의 연결 제어                         |

---

## 3. 응답 헤더 (Response Headers)

### 기본 응답 정보

| 헤더        | 설명                                                |
| ----------- | --------------------------------------------------- |
| Age         | 응답이 얼마나 오래되었는지                          |
| Public      | 서버가 특정 리소스에 대해 지원하는 요청 메서드 목록 |
| Retry-After | 리소스가 사용 불가능할 때 재시도 시점               |
| Server      | 서버 애플리케이션의 이름과 버전                     |
| Title       | HTML 문서의 제목                                    |
| Warning     | 응답 규격보다 상세한 경고 메시지                    |

---

### 협상 관련

| 헤더          | 설명                                                  |
| ------------- | ----------------------------------------------------- |
| Accept-Ranges | 서버가 범위 요청(Range)을 지원하는 형태               |
| Vary          | 응답이 특정 요청 헤더 값에 따라 달라질 수 있음을 알림 |

---

### 응답 보안/인증

| 헤더               | 설명                                          |
| ------------------ | --------------------------------------------- |
| Proxy-Authenticate | 프록시 서버가 요구하는 인증 방식 목록         |
| Set-Cookie         | 서버가 클라이언트에 쿠키를 설정               |
| Set-Cookie2        | 확장 쿠키 (현재는 거의 사용되지 않음)         |
| WWW-Authenticate   | 서버가 클라이언트에게 요구하는 인증 방식 목록 |

⸻

# 2025년 10월 3일 — HTTP 헤더 정리 (엔티티 헤더 - 3장 완료)

⸻

## 3.5 헤더

- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.
- 표준 HTTP 헤더와 명세에 정의되지 않은 헤더들이 존재한다.
- 헤더는 다음 다섯 가지로 분류된다:
  - 일반 헤더 (General Headers)
  - 요청 헤더 (Request Headers)
  - 응답 헤더 (Response Headers)
  - 엔티티 헤더 (Entity Headers)
  - 확장 헤더 (Extension Headers)

---

## 엔티티 정보 헤더

| 헤더     | 설명                                                                                       |
| -------- | ------------------------------------------------------------------------------------------ |
| Allow    | 해당 엔티티에서 수행할 수 있는 요청 메서드 목록을 나열한다.                                |
| Location | 엔티티가 실제로 어디에 위치하고 있는지 알려준다. (리소스의 새로운 위치 URI를 알릴 때 사용) |

**핵심 요약**

- Allow → 리소스가 지원하는 HTTP 메서드 명시 (`Allow: GET, POST`)
- Location → 리소스의 새 위치를 알림 (201 Created, 3xx Redirect 시 사용)

---

## 콘텐츠 헤더 (Content Headers)

| 헤더             | 설명                                                                           |
| ---------------- | ------------------------------------------------------------------------------ |
| Content-Base     | 본문에서 사용된 상대 URL을 해석하기 위한 기본 URL                              |
| Content-Encoding | 본문에 적용된 인코딩 방식 (예: gzip, deflate)                                  |
| Content-Language | 본문을 이해하는데 가장 적절한 언어                                             |
| Content-Length   | 본문의 길이(바이트 단위)                                                       |
| Content-Location | 리소스가 실제로 어디에 위치하는지                                              |
| Content-MD5      | 본문의 MD5 체크섬 값 (무결성 확인)                                             |
| Content-Range    | 전체 리소스 중 엔티티가 해당하는 범위를 바이트 단위로 표현 (부분 전송 시 사용) |
| Content-Type     | 엔티티의 MIME 타입 및 문자 인코딩 (예: `text/html; charset=UTF-8`)             |

**핵심 요약**

- Content-\* 헤더는 **본문 자체의 성격**(길이, 언어, 인코딩, 타입 등)을 설명한다.

---

## 엔티티 캐싱 헤더 (Entity Caching Headers)

| 헤더          | 설명                                                               |
| ------------- | ------------------------------------------------------------------ |
| ETag          | 엔티티의 고유 식별 태그 (리소스 버전 관리용)                       |
| Expires       | 엔티티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 만료 시각 |
| Last-Modified | 이 엔티티가 마지막으로 변경된 날짜/시간                            |

**핵심 요약**

- ETag / Last-Modified / Expires → **캐싱·조건부 요청 관리** (리소스 변경 여부 판단)

---

## 참고 자료

- RFC 7230: HTTP/1.1, Part 1: Message Syntax and Routing
- RFC 7231: HTTP/1.1, Part 2: Semantics and Content
- RFC 7232: HTTP/1.1, Part 4: Conditional Requests
- RFC 7233: HTTP/1.1, Part 5: Range Requests
- RFC 7234: HTTP/1.1, Part 6: Caching
- RFC 7235: HTTP/1.1, Part 7: Authentication

[W3C HTTP Protocols](https://www.w3.org/Protocols/)

⸻

# 📖 2025년 10월 10일 — HTTP 4장: 커넥션 관리

⸻

## **4장 커넥션 관리**

HTTP 명세는 HTTP 메시지의 구조와 형식에 대해서는 자세히 다루지만,  
**HTTP 커넥션의 동작 원리와 흐름**에 대해서는 충분히 설명하지 않는다.  
그러나 실제 애플리케이션 개발에서는 이 “커넥션 관리”가 성능과 안정성을 결정짓는 핵심 요소다.

---

### **이 장에서 다루는 주요 내용**

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 **지연(latency)**, **병목(bottleneck)**, **막힘(congestion)** 문제
- **병렬 커넥션**, **Keep-Alive 커넥션**, **파이프라인(pipelining)**을 통한 HTTP 최적화
- 효율적인 **커넥션 관리 규칙과 전략**

---

## **4.1 TCP 커넥션**

HTTP 통신은 **TCP/IP 프로토콜 스택** 위에서 동작한다.  
이는 전 세계의 모든 네트워크 장비가 사용하는 **패킷 교환 네트워크 프로토콜**로,  
클라이언트와 서버가 서로 안정적으로 데이터를 주고받을 수 있게 한다.

- TCP는 데이터가 **손실되거나 손상되지 않고**,  
  **순서가 바뀌지 않은 상태로** 전달될 것을 보장한다.
- TCP 연결이 성립되면, 양측은 **안정적인 통신 채널**을 통해 HTTP 요청/응답 메시지를 교환할 수 있다.

---

## **브라우저가 URL을 입력받아 서버와 통신하는 과정**

| **단계**  | **설명**                                                                                                    |
| --------- | ----------------------------------------------------------------------------------------------------------- |
| **1단계** | 사용자가 브라우저 주소창에 URL을 입력한다.<br>예: `http://www.joes-hardware.com:80/power-tools.html`        |
| **2단계** | 브라우저가 **도메인 이름(www.joes-hardware.com)**을 **DNS를 통해 IP 주소로 변환**한다.<br>예: `204.62.48.3` |
| **3단계** | 브라우저가 **URL에서 포트 번호(기본 80)**를 추출한다.                                                       |
| **4단계** | 브라우저가 **서버의 IP 주소와 포트 번호로 TCP 연결(3-way handshake)**을 시도한다.                           |
| **5단계** | 연결이 성립되면 브라우저는 **HTTP 요청 메시지(GET 등)**를 서버로 전송한다.                                  |
| **6단계** | 서버는 요청을 처리하고, **HTTP 응답 메시지(HTML 문서 등)**를 브라우저로 보낸다.                             |
| **7단계** | 브라우저가 응답을 모두 받으면 **TCP 연결을 종료**한다.                                                      |

---

## **핵심 요약**

- **1~3단계:** 브라우저가 URL을 분석하고 서버의 위치(IP/Port)를 찾는다.
- **4단계:** TCP 연결 수립 (데이터 송수신 준비).
- **5~6단계:** HTTP 요청 및 응답 교환 단계.
- **7단계:** 응답 완료 후 TCP 연결 종료.
- 즉, 전 과정은 **DNS → TCP 연결 → HTTP 통신 → 연결 종료**의 4단계로 요약된다.

---

**정리 포인트**

- HTTP는 **TCP 위에서 동작**하며, 전송 신뢰성과 순서 보장을 TCP가 담당한다.
- 브라우저는 요청마다 TCP 커넥션을 만들고 닫는 과정을 반복하지만,  
  **Keep-Alive**나 **HTTP/2 다중화**를 통해 성능을 최적화할 수 있다.
- 커넥션 관리는 HTTP 성능 튜닝의 핵심 주제이다.

⸻

# 📖 2025년 10월 11일 — HTTP 4장: 커넥션 관리 (TCP의 기초)

⸻

## **4.1.1 신뢰할 수 있는 데이터 전송 통로, TCP**

HTTP 커넥션은 본질적으로 **TCP 커넥션 위에서 동작**한다.  
몇 가지 HTTP 고유의 사용 규칙을 제외하면,  
HTTP는 단순히 **TCP를 통해 데이터를 주고받는 애플리케이션 계층 프로토콜**이다.

---

### **TCP의 핵심 역할**

- TCP는 **인터넷상에서 안정적이고 신뢰할 수 있는 통신**을 보장한다.
- 데이터를 전송할 때, **손실·중복·순서 변경 없이** 정확히 수신 측에 도달하도록 관리한다.
- TCP 커넥션의 한쪽에서 전송한 **바이트 스트림(byte stream)**은  
  반대쪽에서 **정확히 동일한 순서로** 읽을 수 있다.
- 덕분에 HTTP는 데이터 무결성(integrity)을 TCP에 위임하고,  
  **요청/응답 구조 자체에 집중할 수 있다.**

---

### **핵심 요약**

| 구분                           | 설명                                                      |
| ------------------------------ | --------------------------------------------------------- |
| **HTTP와 TCP의 관계**          | HTTP는 TCP 위에서 동작하는 애플리케이션 계층 프로토콜     |
| **TCP의 목적**                 | 신뢰성 있는 통신 제공 (순서, 무결성 보장)                 |
| **커넥션 특성**                | 클라이언트와 서버 간의 지속적이고 양방향 스트림 기반 통신 |
| **HTTP가 TCP를 사용하는 이유** | 데이터가 손상되지 않고 순서대로 도착하기 때문             |

---

## **4.1.2 TCP 스트림과 IP 패킷**

TCP는 실제로 데이터를 “한 덩어리로” 보내지 않는다.  
대신 데이터를 작은 조각으로 나누어 **IP 패킷(IP Datagram)** 형태로 전송한다.

---

### **프로토콜 계층 구조**

HTTP 통신은 다음과 같은 프로토콜 스택으로 구성된다:

| 계층                          | 프로토콜                                | 설명                                          |
| ----------------------------- | --------------------------------------- | --------------------------------------------- |
| **4계층 (전송 계층)**         | **TCP (Transmission Control Protocol)** | 신뢰성 있는 데이터 전송, 흐름 제어, 순서 보장 |
| **3계층 (네트워크 계층)**     | **IP (Internet Protocol)**              | 패킷을 목적지로 전달 (주소 지정 및 라우팅)    |
| **7계층 (애플리케이션 계층)** | **HTTP (HyperText Transfer Protocol)**  | 웹 요청/응답 메시지 처리                      |
| _(보안 계층)_                 | **TLS / SSL**                           | 암호화 및 인증 제공 (HTTPS에서 사용)          |

---

### **전송 과정 요약**

1. HTTP는 데이터를 **TCP 스트림 형태로 보냄**
2. TCP는 이 스트림을 여러 개의 **세그먼트(segment)**로 분할
3. 각 세그먼트는 IP 계층을 통해 **IP 패킷(datagram)**으로 전송
4. 수신 측 TCP는 세그먼트를 재조립하여 **원래의 순서로 복원**
5. HTTP는 이 완성된 데이터 스트림을 사용하여 응답을 처리

---

### **핵심 요약**

| 항목                  | 설명                                                             |
| --------------------- | ---------------------------------------------------------------- |
| **TCP 스트림**        | 데이터가 연속된 바이트 흐름으로 처리되는 전송 방식               |
| **세그먼트(segment)** | TCP가 데이터를 일정 크기로 분할한 조각                           |
| **IP 패킷(datagram)** | 실제 네트워크 상에서 전송되는 최소 단위                          |
| **HTTPS**             | HTTP + TLS(또는 SSL) = 암호화된 TCP 통신                         |
| **결론**              | TCP는 HTTP의 “안정적 운반 수단”, IP는 그 “배송 경로” 역할을 담당 |

---

**정리 포인트**

- HTTP는 TCP 위에서 동작하며, TCP는 IP 위에서 동작한다.
- TCP는 신뢰성과 순서 보장을 제공하여, HTTP가 손쉽게 요청/응답 메시지를 교환하도록 돕는다.
- HTTPS는 TCP와 HTTP 사이에 **TLS 계층을 삽입**하여 암호화와 인증을 추가한 형태이다.
- 따라서, 웹 통신은 “**IP 위의 TCP 위의 HTTP**”로 요약된다.

---

⸻

# 📖 2025년 10월 12일 — TCP 커넥션 유지 및 소켓 프로그래밍

⸻

## 4.1.3 TCP 커넥션 유지하기

컴퓨터는 항상 여러 개의 TCP 커넥션을 유지할 수 있다.  
TCP는 **포트 번호(port number)**를 이용하여 이러한 커넥션들을 구분한다.

- 포트 번호는 회사 직원의 **내선번호**처럼 특정 애플리케이션을 구분한다.
- **IP 주소**는 컴퓨터를 식별하고, **포트 번호**는 그 안의 애플리케이션을 식별한다.

TCP 커넥션은 다음 네 가지 값으로 유일하게 식별된다.

| 구성 요소        | 설명                     |
| ---------------- | ------------------------ |
| 발신자 IP 주소   | 데이터를 보내는 쪽의 IP  |
| 발신자 포트 번호 | 송신 애플리케이션의 포트 |
| 수신자 IP 주소   | 데이터를 받는 쪽의 IP    |
| 수신자 포트 번호 | 수신 애플리케이션의 포트 |

> 이 네 가지 값이 완전히 동일한 TCP 커넥션은 존재할 수 없다.  
> 다만, 일부 구성요소(IP나 포트)는 다른 커넥션과 중복될 수 있다.

---

## 4.1.4 TCP 소켓 프로그래밍

운영체제는 TCP 커넥션의 생성과 관리에 필요한 여러 기능(API)을 제공한다.  
**소켓(Socket)**은 TCP 커넥션의 한쪽 끝(endpoint)을 나타내며,  
이를 통해 데이터를 송수신할 수 있다.

---

### TCP 소켓 주요 API 정리

| 소켓 API 호출               | 설명                                                       |
| --------------------------- | ---------------------------------------------------------- |
| `s = socket(parameters)`    | 연결이 되지 않은 익명의 새로운 소켓 생성                   |
| `bind(s, localIP:port)`     | 소켓에 로컬 포트 번호와 인터페이스 할당                    |
| `connect(s, remoteIP:port)` | 로컬의 소켓과 원격의 호스트 및 포트 사이에 TCP 커넥션 생성 |
| `listen(s, …)`              | 커넥션을 받아들이기 위해 포트에서 연결 요청을 표시         |
| `s2 = accept(s)`            | 누군가 연결 요청을 보내면 커넥션을 맺기 위해 대기          |
| `n = read(s, buffer, n)`    | 소켓으로부터 바이트 데이터를 읽기 시도                     |
| `n = write(s, buffer, n)`   | 소켓으로부터 바이트 데이터를 쓰기 시도                     |
| `close(s)`                  | TCP 커넥션의 일반적인 종료                                 |
| `shutdown(s, {side})`       | TCP 커넥션의 한쪽 방향만 종료                              |
| `getsockopts(…)`            | 내부 소켓 옵션 정보 조회                                   |
| `setsockopts(…)`            | 내부 소켓 옵션 설정 변경                                   |

---

### 요약

- **연결 준비 단계:** `socket`, `bind`, `connect`
- **데이터 송수신:** `read`, `write`
- **연결 종료:** `close`, `shutdown`
- **옵션 제어:** `getsockopts`, `setsockopts`

> TCP API는 핸드셰이킹, 패킷 분할, 오류 복구 등의 세부 동작을 자동으로 처리한다.  
> 개발자는 단순히 **소켓을 통해 데이터 송수신만 구현**하면 된다.

---

## 4.2 TCP 성능에 대한 고려

HTTP는 TCP 위에서 동작하기 때문에,  
**HTTP 트랜잭션의 성능은 TCP 성능에 직접적인 영향을 받는다.**

- TCP의 **지연(latency)**, **혼잡(congestion)**, **병목(bottleneck)**을 이해해야 한다.
- 이를 기반으로 **HTTP 커넥션 관리 및 최적화(keep-alive, 파이프라이닝 등)**가 가능하다.

> TCP 성능 세부 내용에 관심이 없다면,  
> 다음 절인 **HTTP 커넥션 관리**로 바로 넘어가도 된다.
